<link rel="stylesheet" type="text/css" href="/css/site.css" media="screen" />
<link rel="stylesheet" type="text/css" href="/css/typesystem.css" media="screen "/>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Miltonian" />
<div>
<header class="layout-row bb layout-align-center px-1">
  <div>
    <h1><a href="/index.html">ZK-SecreC Documentation</a></h1>
  </div>
  <div class="flex">
    
  </div>
  <div>
    2024.09
  </div>
</header>
</div>
<div class="layout-row flex">
  <aside class="br visible">
    <nav class="px-2 layout-col">
          <a class="toc-level-0" href="/1-user-guide/0-installation.html">Docs Md</a>
          <a class="toc-level-1" href="/1-user-guide/0-installation.html">User Guide</a>
          <a class="toc-level-2" href="/1-user-guide/0-installation.html">Installation</a>
          <a class="toc-level-2" href="/1-user-guide/1-getting-started.html">Getting Started</a>
          <a class="toc-level-1" href="/2-dev-guide/0-profiling.html">Dev Guide</a>
          <a class="toc-level-2" href="/2-dev-guide/0-profiling.html">Profiling</a>
          <a class="toc-level-1" href="/3-reference/0-values-and-types.html">Reference</a>
          <a class="toc-level-2" href="/3-reference/0-values-and-types.html">Values and Types</a>
          <a class="toc-level-2" href="/3-reference/1-lexical-structure.html">Lexical Structure</a>
          <a class="toc-level-2" href="/3-reference/2-type-level-expressions.html">Type Level Expressions</a>
          <a class="toc-level-2" href="/3-reference/3-expressions.html">Expressions</a>
          <a class="toc-level-2" href="/3-reference/4-top-level.html">Top Level</a>
          <a class="toc-level-2" href="/3-reference/5-type-system.html">Type System</a>
          <a class="toc-level-2" href="/3-reference/6-boxed-and-unboxed-types.html">Boxed and Unboxed Types</a>
          <a class="toc-level-1" href="/4-api/BigInt.html">Api</a>
          <a class="toc-level-2" href="/4-api/BigInt.html">BigInt</a>
          <a class="toc-level-2" href="/4-api/Bitextract.html">Bitextract</a>
          <a class="toc-level-2" href="/4-api/Builtin.html">Builtin</a>
          <a class="toc-level-2" href="/4-api/Char.html">Char</a>
          <a class="toc-level-2" href="/4-api/ChrVec.html">ChrVec</a>
          <a class="toc-level-2" href="/4-api/Date.html">Date</a>
          <a class="toc-level-2" href="/4-api/DFA.html">DFA</a>
          <a class="toc-level-2" href="/4-api/EC.html">EC</a>
          <a class="toc-level-2" href="/4-api/FastFixedPoint.html">FastFixedPoint</a>
          <a class="toc-level-2" href="/4-api/FastFixedPointVec.html">FastFixedPointVec</a>
          <a class="toc-level-2" href="/4-api/FixedPoint.html">FixedPoint</a>
          <a class="toc-level-2" href="/4-api/Inequalities.html">Inequalities</a>
          <a class="toc-level-2" href="/4-api/Integer.html">Integer</a>
          <a class="toc-level-2" href="/4-api/IsFromFirst.html">IsFromFirst</a>
          <a class="toc-level-2" href="/4-api/OldInequalities.html">OldInequalities</a>
          <a class="toc-level-2" href="/4-api/Perm.html">Perm</a>
          <a class="toc-level-2" href="/4-api/Poseidon.html">Poseidon</a>
          <a class="toc-level-2" href="/4-api/Prob.html">Prob</a>
          <a class="toc-level-2" href="/4-api/Ratio.html">Ratio</a>
          <a class="toc-level-2" href="/4-api/SetOp.html">SetOp</a>
          <a class="toc-level-2" href="/4-api/Std.html">Std</a>
          <a class="toc-level-2" href="/4-api/Store.html">Store</a>
          <a class="toc-level-2" href="/4-api/StoreVec.html">StoreVec</a>
          <a class="toc-level-2" href="/4-api/String.html">String</a>
          <a class="toc-level-2" href="/4-api/Text.html">Text</a>
          <a class="toc-level-2" href="/4-api/Vec.html">Vec</a>
          <a class="toc-level-2" href="/4-api/Waksman.html">Waksman</a>
          <a class="toc-level-1" href="/5-backend-interface/0-interfacing-a-new-backend.html">Backend Interface</a>
          <a class="toc-level-2" href="/5-backend-interface/0-interfacing-a-new-backend.html">Interfacing a New Backend</a>
          <a class="toc-level-2" href="/5-backend-interface/1-trait-methods.html">Trait Methods</a>
        </nav>
  </aside>
  <div class="px-2 pb-5 body">
<div>
  <h1>Module IsFromFirst</h1>
</div>
<div>
  <h2>Function is_from_first</h2>
</div>
<code>
pub  fn is_from_first
[
N : Nat
]
(   x : list[uint[N] $post <span class="citation" data-cites="verifier">@verifier</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : list[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
  ref sizeasserter : SizeAsserter[N, $post, <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; list[bool[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Challenge[N]
</code>
<div>
  <blockquote>
  <p>The concatenation of the given two lists, with all elements replaced with booleans indicating if the element occurs in the first given list. Fails if either argument list contains an element that is not representable using the number of bits specified in the given SizeAsserter object.</p>
  </blockquote>
</div>
<div>
  <h2>Function is_prefixed_by_last</h2>
</div>
<code>
pub  fn is_prefixed_by_last
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   xs : list[uint[N] $S <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   lens : list[uint[N] $S <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   maxlen : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; list[bool[N] $S <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>The first argument list, each element having been replaced with a boolean indicating if the previous element is a prefix of this element, where the original elements are interpreted as strings that evaluate to them via the <code>String::eval_string</code> function. Assumes that the strings consist of 8-bit characters and their lengths are given in the second argument list. The third argument is assumed to be an upper bound of all the lengths.</p>
  </blockquote>
</div>
<div>
  <h2>Function is_prefixed_from_first</h2>
</div>
<code>
unchecked eff [*] -&gt; [*] -&gt; [*] -&gt; [*] -&gt; * -&gt; [<em>,</em>,[*]] -&gt; [*] ! &lt;<span class="citation" data-cites="public">@public</span>&gt;<br>
pub  fn is_prefixed_from_first
[
N : Nat
]
(   xs : list[uint[N] $post <span class="citation" data-cites="verifier">@verifier</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : list[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   xlens : list[uint[N] $post <span class="citation" data-cites="verifier">@verifier</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ylens : list[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   maxlen : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>,
  ref sizeasserter : SizeAsserter[N, $post, <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; list[bool[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Challenge[N]
</code>
<div>
  <blockquote>
  <p>The concatenation of the first two argument lists, with all elements replaced with booleans indicating if the element has a prefix occurring in the first given list, where the original elements are interpreted as strings that evaluate to them via the <code>String::eval_string</code> function. Assumes that the strings consist of 8-bit characters and their lengths are given as the third and the fourth argument list. The fifth argument is assumed to be an upper bound of all the lengths. Fails if either of the first two lists contains an element that is not representable using the number of bits specified in the given SizeAsserter object.</p>
  </blockquote>
</div>
<div>
  <h2>Function string_is_from_first</h2>
</div>
<code>
pub  fn string_is_from_first
[
N : Nat
]
(   instances : list[String[$post, <span class="citation" data-cites="verifier">@verifier</span>, N] $pre <span class="citation" data-cites="public">@public</span>] $pre <span class="citation" data-cites="public">@public</span>,
   witnesses : list[String[$post, <span class="citation" data-cites="prover">@prover</span>, N] $pre <span class="citation" data-cites="public">@public</span>] $pre <span class="citation" data-cites="public">@public</span>,
  ref sizeasserter : SizeAsserter[N, $post, <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; list[bool[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Challenge[N]
</code>
<div>
  <blockquote>
  <p>The concatenation of the given two lists, with all elements replaced with booleans indicating if the element occurs in the first given list. Assumes that all String objects in the given lists consist of 8-bit characters and evaluate (via the <code>String::eval_string</code> function) to a number less than the modulus. Fails if either argument list contains a String object whose value is not representable using the number of bits specified in the given SizeAsserter object.</p>
  </blockquote>
</div>

  </div>
</div>
