{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview of ZK-SecreC language ZK-SecreC is a programming language for writing zero-knowledge proofs.","title":"Home"},{"location":"#overview-of-zk-secrec-language","text":"ZK-SecreC is a programming language for writing zero-knowledge proofs.","title":"Overview of ZK-SecreC language"},{"location":"1-user-guide/0-installation/","text":"Installation Frontend and backend The ZK-SecreC compiler is divided into two parts called the frontend and the backend. The frontend contains a lexer, parser, type and effect checker, and a translator to a simpler intermediate language called Core ZK-SecreC. The frontend has been written in Haskell. The backend compiles the intermediate representation into Circuit-IR. The backend has been written in Rust. An intermediate part of the compiler, written in Haskell, generates Rust functions that, along with the compiler backend code, generate the compiled target code. The backend of the ZK-SecreC compiler is also able to interface with ZKP protocol implementations like the EMP toolkit and Mac'n'Cheese. Building locally Building locally is a good option if you wish to develop ZK-SecreC tools. The following steps install the ZK-SecreC compiler and language server (but not Visual Studio Code plugin). The first step is to install the stack build tool. On Debian based distributions one can write: $ sudo apt install haskell-stack On macOS a fast way to get started is also to install haskell-stack using Homebrew: $ brew install haskell-stack If this leads to trouble, refer to the troubleshooting/installation guide at https://docs.haskellstack.org/en/stable/install_and_upgrade/##macos ZK-SecreC requires a relatively new version of stack (> 2). If your distribution has an older version of stack , you can upgrade it with: $ stack upgrade and then add ~/.local/bin to your PATH . You can now compile and install the ZK-SecreC compiler frontend and language server with: $ stack install Stack will locally install the correct version of GHC for you before building. If builds inexplicably start to fail during development, it can, in some situations, be fixed with: $ stack clean && stack install It is possible to build the compiler frontend without installing using stack build . Repeating this command will recompile the compiler frontend if any code has been changed. Using the ZK-SecreC compiler backend requires an installation of the Rust toolchain. The recommended method of installing it is by using Rustup . Running tests Unit tests of the Haskell part of the compiler can be run with: $ stack test --test-arguments \"--color\" Using the compiler The entrypoint to invoking the compiler is the script runrust in the repository root. The script generates the Rust source code, compiles it, and executes the resulting binary which outputs the IR. Usage instructions are provided by running the script without any arguments: $ ./runrust For example, to generate the Circuit-IR code out of the ZK-SecreC example code in docs/example_sum.zksc , one can run the command $ runrust docs/example_sum.zksc -p docs/example_sum_public.json -i docs/example_sum_instance.json -w docs/example_sum_witness.json -c docs/example_sum.ccc -o example_sum In the .json files, one passes the public, Verifier and Prover inputs to the program. The Verifier and Prover inputs are known as instance and witness, respectively. More precisely, these are non-expanded instance and witness; if expanded instance and witness are necessary, they must be programmed in the ZK-SecreC code. In the .ccc file, one provides configuration information telling the compiler which fields, plugins etc. are supported by the technology that is going to run the Circuit-IR code. Finally, the argument after the -o flag determines the names of the files where the compiler output will be written. In the current example, the Circuit-IR output is written in the file example_sum.rel in the compiler root directory. In addition, the files example_sum_0.ins and example_sum_0.wit will contain the instance and witness stream (if there were expanded instance and witness, the streams would include them, too). The suffix 0 denotes the index of the field (in the order of declaration in the head of the .rel file). If multiple fields were used then there would be one .ins and .wit file for each of them. If public, Verifier an Prover inputs are provided in this order then the corresponding flags -p , -i and -w can be dropped. So the last command can be shortened as $ runrust docs/example_sum.zksc docs/example_sum_public.json docs/example_sum_instance.json docs/example_sum_witness.json -c docs/example_sum.ccc -o example_sum or, using regular expressions recognized by the shell, even as $ runrust docs/example_sum.zksc docs/example_sum_{public,instance,witness}.json -c docs/example_sum.ccc -o example_sum Using the compiler frontend alone Sometimes one wants to run the compiler frontend alone. This can be done using the command zkscc , provided that the compiler has been installed. Its short manual is output by $ zkscc --help For instance, in order to compile the file docs/example_sum.zksc with configuration (CCC) file cfg/permitall.ccc and generate output example_sum.rs into the compiler root directory, run $ zkscc docs/example_sum.zksc -c cfg/permitall.ccc -o example_sum.rs To do the same without having installed the compiler, one can write: $ stack run zkscc -- docs/example_sum.zksc -c cfg/permitall.ccc -o example_sum.rs Note the double dash which is required to separate arguments of stack from arguments of zkscc . This command will recompile the compiler if it has been changed. To do the same without recompiling, use stack exec in otherwise identical manner. ZK-SecreC vscode extension The vscode extension adds syntax highlighting and language server integration. Currently only syntax and typing errors are shown. The vscode extension needs the zksc-language-server to be installed (see above). Building the VS Code extension Install npm and node using nvm . This is necessary as the version of nodejs that Ubuntu supplies is most likely too old. Install project dependencies (in the vscode-zksc directory): $ npm ci Compile: $ export NODE_OPTIONS=--openssl-legacy-provider $ npm run package Note that defining NODE_OPTIONS might not be necessary but it is required with some older OpenSSL versions. Installing Open the extensions manager in VS Code (shortcut: Ctrl + Shift + X). Open the menu with the ellipsis icon (...) on the right of the EXTENSIONS title. Choose \"Install from VSIX...\". Locate the *.vsix file that you built and click Install. Configuring Press Ctrl + , to open the settings. Search for \"zk-secrec\". You will find ZK-SecreC extension configuration options. Change the server path to where your zksc-language-server binary is. Note that there is no variable expansion here. Running in VS Code Extension Development mode This is useful if you are developing the extension. Open the project in VS Code. Compile the extension using npm run compile . In VS Code press F5 or click Run -> Start Debugging in the menu. Choose VS Code Extension Development from the menu that opened. Remember to configure the language server path before opening ZK-SecreC files. If you make changes to the code you will have to recompile the program or use npm run watch . You can restart VS Code Extension Development mode using Ctrl + Shift + P and searching for \"Developer: Reload Window\" in the opened menu. Known limitations VS Code has a workspace concept. This extension currently only works if you have one workspace which is likely to be sufficient for ZK-SecreC programming. The extension is untested with multiple workspaces and is likely to have bugs in that case. Building and using the \"production\" Docker image The Dockerfile in the top-level directory builds a minimal docker image with just the compiler. Build the image: $ docker build -t zkscc . Save the image as .tar.gz file: $ docker save zkscc | gzip > zkscc.tar.gz The image can be re-created from the .tar.gz file using: $ docker load --input zkscc.tar.gz When running a container from the image you would probably want to access your ZK-SecreC programs in the container. The simplest option for this is to use bind mounts . Let's assume that the local directory foo contains ZK-SecreC programs. Run a container using: $ docker run -it --rm -v \"$(pwd)/foo\":/zksc/workspace/foo zkscc /bin/bash The foo directory is now available in the working directory. The image is bootstrapped with the Rust toolchain and the runrust script, so the Rust compilation pipeline can also be run the same as locally. The same container can be restarted if needed with docker start c followed by docker attach c , where c is the container identifier. The Docker image can also be used non-interactively as a base image for other application specific images (e.g. demonstrators). Using Visual Studio Code Docker dev container This option is convenient if you wish to use the ZK-SecreC tools but not necessarily develop them further. It gives you access to the ZK-SecreC compiler and an IDE which you can use to develop proofs. Dependencies Visual Studio Code , Docker . Installation steps Open VS Code. Open the Extensions panel using Ctrl + Shift + X or by clicking on the package icon in the left sidebar. Search for \"remote containers\" and install the \"Remote - Containers\" extension. Run docker build -t zkscc . in the repository root to build and tag the dev container base image. If you open the directory of this repository in VS Code it will now offer you to open the directory in the dev container with ZK-SecreC tools. After VS Code has opened the dev container it has installed the ZK-SecreC extension as well. You can now work on .zksc files in the repository directory. Open the panel (Ctrl + J or View -> Appearance -> Show Panel). Click on the terminal tab. If no terminal is opened click the plus sign on the right of the panel. You now have a shell running inside of the container and the repository files are mounted in the container. To use the Rust compilation pipeline, call the script included in the environment's path, e.g. runrust . EMP Backend EMP is a ZK toolkit written in C++ which allows a prover and verifier to perform arithmetic and boolean operations. The \"EMP backend\" replaces SIEVE IR generation with calls to the emp backend code instead, allowing an interactive execution session of the .zksc code using the emp runtime. The way this works is through a small wrapper named emp-wrapper which exposes the necessary functionality. Then, Rust bindings are generated for that wrapper using bindgen which is then called by the generated Rust code. Installation To install the EMP backend you need to compile the emp-wrapper library. The build instructions for that are in the ./emp-wrapper readme. Usage The EMP backend can only be called through Rust via the runrust command. Calling ./runrust will show details of the available flags (notably --emp ). You will need two run two instances of the program, one with --emp --prover and the other with --emp --verifier . Building the two instances of the program nearly at the same time can result in them not successfully connecting. If running EMP toolkit over the network, use the --emp-addr flag to specify address and port. Quirks emp-toolkit has two kinds of integers: bit vectors and fixed-precision integers. The current EMP backend as of 2022-08-15 only has bindings for the fixed-precision kind, which operates in the Mersenne61 modulus. For larger numbers you can use the BigInt.zksc module from the standard library. Booleans are also encoded as M61 integers, and logical operations are done through arithmetic ones. This means that in efficiency they are ranked as: and , >> , or , >>>> , xor .","title":"Installation"},{"location":"1-user-guide/0-installation/#installation","text":"","title":"Installation"},{"location":"1-user-guide/0-installation/#frontend-and-backend","text":"The ZK-SecreC compiler is divided into two parts called the frontend and the backend. The frontend contains a lexer, parser, type and effect checker, and a translator to a simpler intermediate language called Core ZK-SecreC. The frontend has been written in Haskell. The backend compiles the intermediate representation into Circuit-IR. The backend has been written in Rust. An intermediate part of the compiler, written in Haskell, generates Rust functions that, along with the compiler backend code, generate the compiled target code. The backend of the ZK-SecreC compiler is also able to interface with ZKP protocol implementations like the EMP toolkit and Mac'n'Cheese.","title":"Frontend and backend"},{"location":"1-user-guide/0-installation/#building-locally","text":"Building locally is a good option if you wish to develop ZK-SecreC tools. The following steps install the ZK-SecreC compiler and language server (but not Visual Studio Code plugin). The first step is to install the stack build tool. On Debian based distributions one can write: $ sudo apt install haskell-stack On macOS a fast way to get started is also to install haskell-stack using Homebrew: $ brew install haskell-stack If this leads to trouble, refer to the troubleshooting/installation guide at https://docs.haskellstack.org/en/stable/install_and_upgrade/##macos ZK-SecreC requires a relatively new version of stack (> 2). If your distribution has an older version of stack , you can upgrade it with: $ stack upgrade and then add ~/.local/bin to your PATH . You can now compile and install the ZK-SecreC compiler frontend and language server with: $ stack install Stack will locally install the correct version of GHC for you before building. If builds inexplicably start to fail during development, it can, in some situations, be fixed with: $ stack clean && stack install It is possible to build the compiler frontend without installing using stack build . Repeating this command will recompile the compiler frontend if any code has been changed. Using the ZK-SecreC compiler backend requires an installation of the Rust toolchain. The recommended method of installing it is by using Rustup .","title":"Building locally"},{"location":"1-user-guide/0-installation/#running-tests","text":"Unit tests of the Haskell part of the compiler can be run with: $ stack test --test-arguments \"--color\"","title":"Running tests"},{"location":"1-user-guide/0-installation/#using-the-compiler","text":"The entrypoint to invoking the compiler is the script runrust in the repository root. The script generates the Rust source code, compiles it, and executes the resulting binary which outputs the IR. Usage instructions are provided by running the script without any arguments: $ ./runrust For example, to generate the Circuit-IR code out of the ZK-SecreC example code in docs/example_sum.zksc , one can run the command $ runrust docs/example_sum.zksc -p docs/example_sum_public.json -i docs/example_sum_instance.json -w docs/example_sum_witness.json -c docs/example_sum.ccc -o example_sum In the .json files, one passes the public, Verifier and Prover inputs to the program. The Verifier and Prover inputs are known as instance and witness, respectively. More precisely, these are non-expanded instance and witness; if expanded instance and witness are necessary, they must be programmed in the ZK-SecreC code. In the .ccc file, one provides configuration information telling the compiler which fields, plugins etc. are supported by the technology that is going to run the Circuit-IR code. Finally, the argument after the -o flag determines the names of the files where the compiler output will be written. In the current example, the Circuit-IR output is written in the file example_sum.rel in the compiler root directory. In addition, the files example_sum_0.ins and example_sum_0.wit will contain the instance and witness stream (if there were expanded instance and witness, the streams would include them, too). The suffix 0 denotes the index of the field (in the order of declaration in the head of the .rel file). If multiple fields were used then there would be one .ins and .wit file for each of them. If public, Verifier an Prover inputs are provided in this order then the corresponding flags -p , -i and -w can be dropped. So the last command can be shortened as $ runrust docs/example_sum.zksc docs/example_sum_public.json docs/example_sum_instance.json docs/example_sum_witness.json -c docs/example_sum.ccc -o example_sum or, using regular expressions recognized by the shell, even as $ runrust docs/example_sum.zksc docs/example_sum_{public,instance,witness}.json -c docs/example_sum.ccc -o example_sum","title":"Using the compiler"},{"location":"1-user-guide/0-installation/#using-the-compiler-frontend-alone","text":"Sometimes one wants to run the compiler frontend alone. This can be done using the command zkscc , provided that the compiler has been installed. Its short manual is output by $ zkscc --help For instance, in order to compile the file docs/example_sum.zksc with configuration (CCC) file cfg/permitall.ccc and generate output example_sum.rs into the compiler root directory, run $ zkscc docs/example_sum.zksc -c cfg/permitall.ccc -o example_sum.rs To do the same without having installed the compiler, one can write: $ stack run zkscc -- docs/example_sum.zksc -c cfg/permitall.ccc -o example_sum.rs Note the double dash which is required to separate arguments of stack from arguments of zkscc . This command will recompile the compiler if it has been changed. To do the same without recompiling, use stack exec in otherwise identical manner.","title":"Using the compiler frontend alone"},{"location":"1-user-guide/0-installation/#zk-secrec-vscode-extension","text":"The vscode extension adds syntax highlighting and language server integration. Currently only syntax and typing errors are shown. The vscode extension needs the zksc-language-server to be installed (see above).","title":"ZK-SecreC vscode extension"},{"location":"1-user-guide/0-installation/#building-the-vs-code-extension","text":"Install npm and node using nvm . This is necessary as the version of nodejs that Ubuntu supplies is most likely too old. Install project dependencies (in the vscode-zksc directory): $ npm ci Compile: $ export NODE_OPTIONS=--openssl-legacy-provider $ npm run package Note that defining NODE_OPTIONS might not be necessary but it is required with some older OpenSSL versions.","title":"Building the VS Code extension"},{"location":"1-user-guide/0-installation/#installing","text":"Open the extensions manager in VS Code (shortcut: Ctrl + Shift + X). Open the menu with the ellipsis icon (...) on the right of the EXTENSIONS title. Choose \"Install from VSIX...\". Locate the *.vsix file that you built and click Install.","title":"Installing"},{"location":"1-user-guide/0-installation/#configuring","text":"Press Ctrl + , to open the settings. Search for \"zk-secrec\". You will find ZK-SecreC extension configuration options. Change the server path to where your zksc-language-server binary is. Note that there is no variable expansion here.","title":"Configuring"},{"location":"1-user-guide/0-installation/#running-in-vs-code-extension-development-mode","text":"This is useful if you are developing the extension. Open the project in VS Code. Compile the extension using npm run compile . In VS Code press F5 or click Run -> Start Debugging in the menu. Choose VS Code Extension Development from the menu that opened. Remember to configure the language server path before opening ZK-SecreC files. If you make changes to the code you will have to recompile the program or use npm run watch . You can restart VS Code Extension Development mode using Ctrl + Shift + P and searching for \"Developer: Reload Window\" in the opened menu.","title":"Running in VS Code Extension Development mode"},{"location":"1-user-guide/0-installation/#known-limitations","text":"VS Code has a workspace concept. This extension currently only works if you have one workspace which is likely to be sufficient for ZK-SecreC programming. The extension is untested with multiple workspaces and is likely to have bugs in that case.","title":"Known limitations"},{"location":"1-user-guide/0-installation/#building-and-using-the-production-docker-image","text":"The Dockerfile in the top-level directory builds a minimal docker image with just the compiler. Build the image: $ docker build -t zkscc . Save the image as .tar.gz file: $ docker save zkscc | gzip > zkscc.tar.gz The image can be re-created from the .tar.gz file using: $ docker load --input zkscc.tar.gz When running a container from the image you would probably want to access your ZK-SecreC programs in the container. The simplest option for this is to use bind mounts . Let's assume that the local directory foo contains ZK-SecreC programs. Run a container using: $ docker run -it --rm -v \"$(pwd)/foo\":/zksc/workspace/foo zkscc /bin/bash The foo directory is now available in the working directory. The image is bootstrapped with the Rust toolchain and the runrust script, so the Rust compilation pipeline can also be run the same as locally. The same container can be restarted if needed with docker start c followed by docker attach c , where c is the container identifier. The Docker image can also be used non-interactively as a base image for other application specific images (e.g. demonstrators).","title":"Building and using the \"production\" Docker image"},{"location":"1-user-guide/0-installation/#using-visual-studio-code-docker-dev-container","text":"This option is convenient if you wish to use the ZK-SecreC tools but not necessarily develop them further. It gives you access to the ZK-SecreC compiler and an IDE which you can use to develop proofs.","title":"Using Visual Studio Code Docker dev container"},{"location":"1-user-guide/0-installation/#dependencies","text":"Visual Studio Code , Docker .","title":"Dependencies"},{"location":"1-user-guide/0-installation/#installation-steps","text":"Open VS Code. Open the Extensions panel using Ctrl + Shift + X or by clicking on the package icon in the left sidebar. Search for \"remote containers\" and install the \"Remote - Containers\" extension. Run docker build -t zkscc . in the repository root to build and tag the dev container base image. If you open the directory of this repository in VS Code it will now offer you to open the directory in the dev container with ZK-SecreC tools. After VS Code has opened the dev container it has installed the ZK-SecreC extension as well. You can now work on .zksc files in the repository directory. Open the panel (Ctrl + J or View -> Appearance -> Show Panel). Click on the terminal tab. If no terminal is opened click the plus sign on the right of the panel. You now have a shell running inside of the container and the repository files are mounted in the container. To use the Rust compilation pipeline, call the script included in the environment's path, e.g. runrust .","title":"Installation steps"},{"location":"1-user-guide/0-installation/#emp-backend","text":"EMP is a ZK toolkit written in C++ which allows a prover and verifier to perform arithmetic and boolean operations. The \"EMP backend\" replaces SIEVE IR generation with calls to the emp backend code instead, allowing an interactive execution session of the .zksc code using the emp runtime. The way this works is through a small wrapper named emp-wrapper which exposes the necessary functionality. Then, Rust bindings are generated for that wrapper using bindgen which is then called by the generated Rust code.","title":"EMP Backend"},{"location":"1-user-guide/0-installation/#installation_1","text":"To install the EMP backend you need to compile the emp-wrapper library. The build instructions for that are in the ./emp-wrapper readme.","title":"Installation"},{"location":"1-user-guide/0-installation/#usage","text":"The EMP backend can only be called through Rust via the runrust command. Calling ./runrust will show details of the available flags (notably --emp ). You will need two run two instances of the program, one with --emp --prover and the other with --emp --verifier . Building the two instances of the program nearly at the same time can result in them not successfully connecting. If running EMP toolkit over the network, use the --emp-addr flag to specify address and port.","title":"Usage"},{"location":"1-user-guide/0-installation/#quirks","text":"emp-toolkit has two kinds of integers: bit vectors and fixed-precision integers. The current EMP backend as of 2022-08-15 only has bindings for the fixed-precision kind, which operates in the Mersenne61 modulus. For larger numbers you can use the BigInt.zksc module from the standard library. Booleans are also encoded as M61 integers, and logical operations are done through arithmetic ones. This means that in efficiency they are ranked as: and , >> , or , >>>> , xor .","title":"Quirks"},{"location":"1-user-guide/1-getting-started/","text":"Getting Started A trivial factorization example In this example, we will write a simple ZK-SecreC program that will read two integers from the witness file and prove that these two numbers are factors of a publicly known integer. First let's create a new ZK-SecreC program: // factors.zksc // The prover wants to convince the verifier of knowing a factorization of 96 type N : Nat = 0xfffffffb; fn main() where Field[N] { let n : uint[N] $pre @public = 96; let x : uint[N] $post @prover = wire { get_witness(\"x\") }; let y : uint[N] $post @prover = wire { get_witness(\"y\") }; let z : uint[N] $post @prover = (wire { n }) as @prover; assert_zero(x * y - z); } The first two lines, starting with // , are comments. The following code line defines N to be a type-level natural number. Its value 2 32 -5 is given in hexadecimal notation. The program contains one function main which is the starting point of the execution. The first line of the body of the main function defines a variable n to hold the public integer 96. The stage qualifier $pre in the type of the variable shows that this value will lie outside the circuit. The next two lines load the values of variables x and y from the witness file using get_witness . We enclose the result of the get_witness function in a wire block, telling that these values should be given to our circuit as inputs. So the stage qualifier of these variables is $post . The fourth line of the body of the function similarly forwards the public integer 96 to the circuit. The as @prover part of the line lifts the number to the prover's domain. This is necessary for the subtraction in the next line to be type correct. Finally, the last line of the body of the main function makes the assertion that the product of the first two inputs equals the last input. Assertions in ZK-SecreC will become the outputs of the circuit. The data type uint[N] occurring in the code is the type of elements of the finite field of size previously assigned to the variable N . The head line of the function (after the keyword where ) declares N to satisfy the type constraint Field . This is necessary for putting values of type uint[N] on wires. For semantic correctness, the value of N must be a prime number. It is the responsibility of the programmer to ensure this property as ZK-SecreC compiler does not check for primality. Note that, although the syntax and type rules of ZK-SecreC allow the order of conversions in the fourth line of the body of the function to be reversed (to obtain wire { n as @prover } ), it is crucial for credibility of the ZK proof to have the order of conversions as shown in the code. Namely, (wire { n }) as @prover first passes the number 96 to the circuit and only then lifts it to the prover's domain. Doing things in the opposite order would mean that the circuit will get the input after the value has been lifted to the prover's domain, which enables the prover to replace the value with whatever other value before passing it to the circuit. Hence the prover could choose the factors arbitrarily and feed the circuit with the product of these factors instead of 96. The proof would succeed incorrectly. Before we can compile this example code, we also need a .json file containing the secret integers. Suppose witness.json has the following contents: { \"x\": \"16\", \"y\": \"6\" } Note the double quotes around both keys and values! The program will use the arguments of the get_witness function as keys of the dictionary in the .json file and reads the corresponding values. So the value of the variable x will be 16 and the value of the variable y will be 6. To compile the program we have to run runrust factors.zksc -w witness.json -o result This creates files result.rel , result_0.wit and result_0.ins . The .rel file contains a list of wires which make up the arithmetic circuit: // File result.rel version 2.1.0; circuit; @type field 4294967291; @begin $0 <- @private(0); $1 <- @private(0); $2 <- @mul(0: $0, $1); $3 <- @addc(0: $2, <4294967195>); @assert_zero(0: $3); @end The header (before @begin ) contains the used version of Circuit-IR, the keyword circuit confirming the type of the file, and a field declaration. This is the size of the only finite field used in the ZK-SecreC program, now written in decimal. Now let's look at the wires (between @begin and @end ). $0 <- @private(0); $1 <- @private(0); These lines tell us that the values of wires $0 and $1 are inputs read from the witness stream, i.e., they are not public. There is one witness stream for every field. The argument of @private indicates the index of the field in the order of declaration in the header. In this example, only one field is used and its index is 0. $2 <- @mul(0: $0, $1); This line declares that the values on wires $0 and $1 are multiplied in the field number 0 and the result is stored on wire $2 . $3 <- @addc(0: $2, <4294967195>); Here, the value of the expression that is going to be asserted zero is stored on the wire $3 . The constant written in angle brackets equals -96 in the finite field in which the computation is performed. So the value on wire $3 will be the difference of the value on wire $2 and the number 96. @assert_zero(0: $3); Finally, the value on wire $3 is asserted to be zero of the field number 0. When we look into the result_0.wit file, we see that it contains the secret values 16 and 6 : // File result_0.wit version 2.1.0; private_input; @type field 4294967291; @begin <16>; <6>; @end The file result_0.ins has an empty body because the verifier's input stream is not used in this example: // File result_0.ins version 2.1.0; public_input; @type field 4294967291; @begin @end When running the zero-knowledge protocol, the prover would have access to the circuit and both input streams, but the verifier would only have the contents of the .rel file and the .ins file. A simple summation example In the second example, we will write a ZK-SecreC program that will read a list of integers from the instance file and claim that their sum equals the number read from the witness file. The ZK-SecreC program looks like this: // summation.zksc // The prover wants to convince the verifier of knowing the total sum of numbers in the verifier's list type N : Nat = 1030307; type M : Nat = 0x10000000000000000; fn main() where Field[N] { let n : uint[M] $pre @public = get_public(\"n\"); let xs_pre : list[uint[N] $pre @verifier] $pre @verifier = get_instance(\"xs\"); let xs = for i in 0 .. n { wire { xs_pre[i as @verifier] } }; let y = wire { get_witness(\"y\") }; let s = sum(xs); assert_zero(s as @prover - y); } The first line of the body of the function main reads a public constant from a .json file. The possibility to put public constants into a .json file is good for keeping data and program logic separate. Note the parameter M with value 2 64 in the data type. ZK-SecreC requires that all loop indices and list lengths are of the integer type with this module. Besides finite fields of prime size, ZK-SecreC supports 8-, 16-, 32-, 64-, and 128-bit integer types, which are written in the form uint[ M ] where M denotes the corresponding modulus 2 8 , 2 16 , 2 32 , 2 64 or 2 128 , and a type uint (without modulus parameter) of integers with unlimited size. The second line of the body of the function main reads the verifier's file. It is assumed that the value of the key \"xs\" is a list of integers. This is reflected in the type annotation. The element type of the list is written in brackets after the list keyword. So the type list[uint[N] $pre @verifier] $pre @verifier establishes that the elements of the list are elements of the finite field of size 1030307 in the verifier's domain outside the circuit, and the list itself is also in the verifier's domain outside the circuit. The third line of the body of the function main passes the elements of the list one by one to the circuit as inputs and forms a new list of the values in circuit. The right-hand side of the definition in this line consists of a for loop which constructs the new list. It uses the previously read value of the variable n as the known length of the list. So we assume that, although the list and its elements are in the verifier domain, the length of the list is actually a public value. The length of the list would become public anyway since it will be reflected in the size of the circuit. The fact that n is public forces the loop index i that runs from 0 up to n to be public, too. In the body of the loop, however, the value of i must be lifted to the verifier's domain because, in order to lookup elements of a list, the index and the list must be in the same domain. For the same reason, the resulting list will be in the public domain since it is indexed by i which is public. Hence the type of xs is list[uint[N] $post @verifier] $pre @public but the type is omitted from the code. ZK-SecreC has built-in type inference which enables omitting types of variables if they can be inferred from context. The fourth line of the body of the function main reads a value from the prover's file and passes it to the circuit. The next line finds the total sum of the verifier's values in the circuit, using a standalone function sum . The last line of the body of main asserts that the sum equals the prover's input. The contents of the .json files could be as follows: public.json : { \"n\": \"7\" } instance.json : { \"xs\": [\"11\", \"22\", \"33\", \"44\", \"55\", \"66\", \"77\"] } witness.json : { \"y\": \"308\" } Let's now study several ways of defining the auxiliary function sum . Using a mutable variable One can introduce a mutable variable that stores the intermediate sums and return its final value: fn sum[$S, @D](xs : list[uint[N] $S @D]) -> uint[N] $S @D { let mut s = 0; for i in 0 .. length(xs) { s = s + xs[i] }; s } The function returns the sum of its argument list that is denoted by the parameter xs . The first line of the body of the function introduces a new mutable variable s . Mutability is established by the keyword mut . In the loop that follows, each element of the argument list is added to the new variable. The final value of this variable will be the total sum. The last line returns it. As it is, the defined function is polymorphic in both stage and domain. The type parameters $S and @D are written in brackets right after the function name. The characters $ and @ in front of the names indicate that the variables denote a stage and a domain, respectively. The declared type of the parameter xs is list[uint[N] $S @D] meaning that the function can work with lists of elements in the finite field of size 1030307 belonging to whatever domain, regardless of being outside or inside the circuit. One can make N also a type parameter of the function by adding N : Nat into the brackets. Currently, N refers to the global constant 1030307. Recursive definition of an auxiliary list One can recursively define a list of partial sums and return its last element: fn sum[$S, @D](xs : list[uint[N] $S @D]) -> uint[N] $S @D { let rec sums = for i in 0 .. length(xs) + 1 { if (i == 0) { 0 } else { sums[i - 1] + xs[i - 1] } }; sums[length(xs)] } The signature of the function is the same as in the previous case. Instead of using an auxiliary mutable variable, the body of the function defines a variable sums to hold a list of all partial sums of elements of the original list. The first element is defined to be zero and each of the following elements is defined as the sum of the current element of the new list and the next element of the original list. Recursion in the local definition is allowed by the keyword rec . The last line of the body of the function returns the last element of the new list which contains precisely the total sum of elements of the original list. Calling the library function The standard library of ZK-SecreC contains a function sum that finds the total sum of its argument list. Hence it suffices to import the corresponding module Std . For that, the following code line has to be added to the file summation.zksc : use Std::*; This library module also defines the type synonym u64 to denote the type uint[0x10000000000000000] . Hence, when using Std , there is no need to define M in the program, and the type uint[M] can be replaced with u64 . Output To compile the program we might run runrust summation.zksc -p public.json -i instance.json -w witness.json -o result All three variants lead to output files (relation description, verifier's input stream, and prover's input stream) with the following contents: // File result.rel version 2.1.0; circuit; @type field 1030307; @begin $0 <- @public(0); $1 <- @public(0); $2 <- @public(0); $3 <- @public(0); $4 <- @public(0); $5 <- @public(0); $6 <- @public(0); $7 <- @private(0); $8 <- @addc(0: $0, <0>); $9 <- @add(0: $8, $1); $10 <- @add(0: $9, $2); $11 <- @add(0: $10, $3); $12 <- @add(0: $11, $4); $13 <- @add(0: $12, $5); $14 <- @add(0: $13, $6); $15 <- @mulc(0: $7, <1030306>); $16 <- @add(0: $14, $15); @assert_zero(0: $16); @end // File result_0.ins version 2.1.0; public_input; @type field 1030307; @begin <11>; <22>; <33>; <44>; <55>; <66>; <77>; @end // File result_0.wit version 2.1.0; private_input; @type field 1030307; @begin <308>; @end A more serious example of factorization In the initial factorization example, the prover might have submitted 1 and 96 as factors of 96 and the proof would still have been successful. Let's study how to update the program in such a way that only non-trivial factorizations would be accepted. This requires checking that neither of the factors is one. Moreover, the initial example allowed the prover to misuse overflow, i.e., cheat by providing two numbers whose product were equal to the verifier's number in the finite field but not in integers. In order to eliminate this possibility, size checks must be added. It is safe to assert that both factor candidates can be represented using less than half of the number of bits in the binary representation of the field size. This excludes overflow when the numbers are multiplied. The following program would work: use Std::*; use Integer::*; use Inequalities::*; type N : Nat = 3647104749702663936044671300410017453855276508776292262406172562348790436137984035021; fn main() where Field[N] { let z : uint[N] $post @verifier = wire { get_instance(\"z\") }; let x : uint[N] $post @prover = wire { get_witness(\"x\") }; let y = wire { z as @prover as $pre / x as $pre }; assert(!eq(x, 1)); assert(!eq(y, 1)); let mut s = sizeasserter_new(((log2(N) - 1) / 2) as u64); let trash = check_size(x, ref s); let trash = check_size(y, ref s); assert_zero(x * y - z as @prover) } The first line of the body of main reads the number to be factorized and passes it to the circuit. The second line similarly reads one factor and passes it to the circuit. In the third line, the second input from the prover goes to the circuit. Instead of reading it from the prover's file, the code instructs the prover to compute this input as the ratio of the verifier's input and the prover's first input. This computation must be delegated outside the circuit as the circuit does not support division. Therefore the stage of the operands must be transformed by as $pre . Computing the second factor instead of reading it from the file is a non-essential change that makes the second factor formally an expanded witness, but it does not cause changes in the resulting prover's stream as the latter does not distinguish between witness and expanded witness. The fourth and fifth line assert that the factor candidates differ from 1. The built-in ZK-SecreC function assert requires a boolean argument and asserts it being true. The eq library function returns true if its two arguments are equal and false otherwise; the unary operator ! negates its boolean argument. This somewhat complicated sequence of operations is necessary since there is no assert_nonzero function. The next three lines deal with checking the size of the factor candidates. For that, a size asserter is created. A size asserter is an object that is able to check that binary representations of numbers fit into a fixed number of bits. The number of bits is given as argument when creating the object. Here, the argument is (log2(N) - 1) / 2 where log2 is the library function that returns the floor of binary logarithm of its argument; note that ZK-SecreC allows the programmer to use type level integers as values of type uint . The result must be cast to type u64 as this is the argument type of the function sizeasserter_new . The actual check is triggered by the library function check_size that takes as arguments the number whose size is checked and a size asserter. The let trash = is there because the result of check_size is not used (similarly to assertions, if the size check fails then the whole ZK proof fails). Note that the size asserter is assigned to a mutable variable, and it is also passed to the function check_size as mutable as indicated by the keyword ref . It is essential to make size asserters mutable since, for computational efficiency, they collect information about the checked numbers throughout the program, thus changing their value at every operation, and do all necessary checks together at the end of their life time. Finally, the last line of the body of main asserts that the product of the claimed factors is indeed equal to the number being factorized. The resulting files will be much larger than in the case of the first example. Therefore we will not present the contents of the resulting files. The body of the .rel file contains 1580 lines and the body of the .wit file contains 284 lines. The large size of witness is caused by library functions that expand the witness. Most of the size explosion is caused by operations with the size asserter (finding out binary representations requires input from the prover) but eq also has to expand witness since equality check along with returning of the result cannot be performed by the circuit alone.","title":"Getting Started"},{"location":"1-user-guide/1-getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"1-user-guide/1-getting-started/#a-trivial-factorization-example","text":"In this example, we will write a simple ZK-SecreC program that will read two integers from the witness file and prove that these two numbers are factors of a publicly known integer. First let's create a new ZK-SecreC program: // factors.zksc // The prover wants to convince the verifier of knowing a factorization of 96 type N : Nat = 0xfffffffb; fn main() where Field[N] { let n : uint[N] $pre @public = 96; let x : uint[N] $post @prover = wire { get_witness(\"x\") }; let y : uint[N] $post @prover = wire { get_witness(\"y\") }; let z : uint[N] $post @prover = (wire { n }) as @prover; assert_zero(x * y - z); } The first two lines, starting with // , are comments. The following code line defines N to be a type-level natural number. Its value 2 32 -5 is given in hexadecimal notation. The program contains one function main which is the starting point of the execution. The first line of the body of the main function defines a variable n to hold the public integer 96. The stage qualifier $pre in the type of the variable shows that this value will lie outside the circuit. The next two lines load the values of variables x and y from the witness file using get_witness . We enclose the result of the get_witness function in a wire block, telling that these values should be given to our circuit as inputs. So the stage qualifier of these variables is $post . The fourth line of the body of the function similarly forwards the public integer 96 to the circuit. The as @prover part of the line lifts the number to the prover's domain. This is necessary for the subtraction in the next line to be type correct. Finally, the last line of the body of the main function makes the assertion that the product of the first two inputs equals the last input. Assertions in ZK-SecreC will become the outputs of the circuit. The data type uint[N] occurring in the code is the type of elements of the finite field of size previously assigned to the variable N . The head line of the function (after the keyword where ) declares N to satisfy the type constraint Field . This is necessary for putting values of type uint[N] on wires. For semantic correctness, the value of N must be a prime number. It is the responsibility of the programmer to ensure this property as ZK-SecreC compiler does not check for primality. Note that, although the syntax and type rules of ZK-SecreC allow the order of conversions in the fourth line of the body of the function to be reversed (to obtain wire { n as @prover } ), it is crucial for credibility of the ZK proof to have the order of conversions as shown in the code. Namely, (wire { n }) as @prover first passes the number 96 to the circuit and only then lifts it to the prover's domain. Doing things in the opposite order would mean that the circuit will get the input after the value has been lifted to the prover's domain, which enables the prover to replace the value with whatever other value before passing it to the circuit. Hence the prover could choose the factors arbitrarily and feed the circuit with the product of these factors instead of 96. The proof would succeed incorrectly. Before we can compile this example code, we also need a .json file containing the secret integers. Suppose witness.json has the following contents: { \"x\": \"16\", \"y\": \"6\" } Note the double quotes around both keys and values! The program will use the arguments of the get_witness function as keys of the dictionary in the .json file and reads the corresponding values. So the value of the variable x will be 16 and the value of the variable y will be 6. To compile the program we have to run runrust factors.zksc -w witness.json -o result This creates files result.rel , result_0.wit and result_0.ins . The .rel file contains a list of wires which make up the arithmetic circuit: // File result.rel version 2.1.0; circuit; @type field 4294967291; @begin $0 <- @private(0); $1 <- @private(0); $2 <- @mul(0: $0, $1); $3 <- @addc(0: $2, <4294967195>); @assert_zero(0: $3); @end The header (before @begin ) contains the used version of Circuit-IR, the keyword circuit confirming the type of the file, and a field declaration. This is the size of the only finite field used in the ZK-SecreC program, now written in decimal. Now let's look at the wires (between @begin and @end ). $0 <- @private(0); $1 <- @private(0); These lines tell us that the values of wires $0 and $1 are inputs read from the witness stream, i.e., they are not public. There is one witness stream for every field. The argument of @private indicates the index of the field in the order of declaration in the header. In this example, only one field is used and its index is 0. $2 <- @mul(0: $0, $1); This line declares that the values on wires $0 and $1 are multiplied in the field number 0 and the result is stored on wire $2 . $3 <- @addc(0: $2, <4294967195>); Here, the value of the expression that is going to be asserted zero is stored on the wire $3 . The constant written in angle brackets equals -96 in the finite field in which the computation is performed. So the value on wire $3 will be the difference of the value on wire $2 and the number 96. @assert_zero(0: $3); Finally, the value on wire $3 is asserted to be zero of the field number 0. When we look into the result_0.wit file, we see that it contains the secret values 16 and 6 : // File result_0.wit version 2.1.0; private_input; @type field 4294967291; @begin <16>; <6>; @end The file result_0.ins has an empty body because the verifier's input stream is not used in this example: // File result_0.ins version 2.1.0; public_input; @type field 4294967291; @begin @end When running the zero-knowledge protocol, the prover would have access to the circuit and both input streams, but the verifier would only have the contents of the .rel file and the .ins file.","title":"A trivial factorization example"},{"location":"1-user-guide/1-getting-started/#a-simple-summation-example","text":"In the second example, we will write a ZK-SecreC program that will read a list of integers from the instance file and claim that their sum equals the number read from the witness file. The ZK-SecreC program looks like this: // summation.zksc // The prover wants to convince the verifier of knowing the total sum of numbers in the verifier's list type N : Nat = 1030307; type M : Nat = 0x10000000000000000; fn main() where Field[N] { let n : uint[M] $pre @public = get_public(\"n\"); let xs_pre : list[uint[N] $pre @verifier] $pre @verifier = get_instance(\"xs\"); let xs = for i in 0 .. n { wire { xs_pre[i as @verifier] } }; let y = wire { get_witness(\"y\") }; let s = sum(xs); assert_zero(s as @prover - y); } The first line of the body of the function main reads a public constant from a .json file. The possibility to put public constants into a .json file is good for keeping data and program logic separate. Note the parameter M with value 2 64 in the data type. ZK-SecreC requires that all loop indices and list lengths are of the integer type with this module. Besides finite fields of prime size, ZK-SecreC supports 8-, 16-, 32-, 64-, and 128-bit integer types, which are written in the form uint[ M ] where M denotes the corresponding modulus 2 8 , 2 16 , 2 32 , 2 64 or 2 128 , and a type uint (without modulus parameter) of integers with unlimited size. The second line of the body of the function main reads the verifier's file. It is assumed that the value of the key \"xs\" is a list of integers. This is reflected in the type annotation. The element type of the list is written in brackets after the list keyword. So the type list[uint[N] $pre @verifier] $pre @verifier establishes that the elements of the list are elements of the finite field of size 1030307 in the verifier's domain outside the circuit, and the list itself is also in the verifier's domain outside the circuit. The third line of the body of the function main passes the elements of the list one by one to the circuit as inputs and forms a new list of the values in circuit. The right-hand side of the definition in this line consists of a for loop which constructs the new list. It uses the previously read value of the variable n as the known length of the list. So we assume that, although the list and its elements are in the verifier domain, the length of the list is actually a public value. The length of the list would become public anyway since it will be reflected in the size of the circuit. The fact that n is public forces the loop index i that runs from 0 up to n to be public, too. In the body of the loop, however, the value of i must be lifted to the verifier's domain because, in order to lookup elements of a list, the index and the list must be in the same domain. For the same reason, the resulting list will be in the public domain since it is indexed by i which is public. Hence the type of xs is list[uint[N] $post @verifier] $pre @public but the type is omitted from the code. ZK-SecreC has built-in type inference which enables omitting types of variables if they can be inferred from context. The fourth line of the body of the function main reads a value from the prover's file and passes it to the circuit. The next line finds the total sum of the verifier's values in the circuit, using a standalone function sum . The last line of the body of main asserts that the sum equals the prover's input. The contents of the .json files could be as follows: public.json : { \"n\": \"7\" } instance.json : { \"xs\": [\"11\", \"22\", \"33\", \"44\", \"55\", \"66\", \"77\"] } witness.json : { \"y\": \"308\" } Let's now study several ways of defining the auxiliary function sum .","title":"A simple summation example"},{"location":"1-user-guide/1-getting-started/#using-a-mutable-variable","text":"One can introduce a mutable variable that stores the intermediate sums and return its final value: fn sum[$S, @D](xs : list[uint[N] $S @D]) -> uint[N] $S @D { let mut s = 0; for i in 0 .. length(xs) { s = s + xs[i] }; s } The function returns the sum of its argument list that is denoted by the parameter xs . The first line of the body of the function introduces a new mutable variable s . Mutability is established by the keyword mut . In the loop that follows, each element of the argument list is added to the new variable. The final value of this variable will be the total sum. The last line returns it. As it is, the defined function is polymorphic in both stage and domain. The type parameters $S and @D are written in brackets right after the function name. The characters $ and @ in front of the names indicate that the variables denote a stage and a domain, respectively. The declared type of the parameter xs is list[uint[N] $S @D] meaning that the function can work with lists of elements in the finite field of size 1030307 belonging to whatever domain, regardless of being outside or inside the circuit. One can make N also a type parameter of the function by adding N : Nat into the brackets. Currently, N refers to the global constant 1030307.","title":"Using a mutable variable"},{"location":"1-user-guide/1-getting-started/#recursive-definition-of-an-auxiliary-list","text":"One can recursively define a list of partial sums and return its last element: fn sum[$S, @D](xs : list[uint[N] $S @D]) -> uint[N] $S @D { let rec sums = for i in 0 .. length(xs) + 1 { if (i == 0) { 0 } else { sums[i - 1] + xs[i - 1] } }; sums[length(xs)] } The signature of the function is the same as in the previous case. Instead of using an auxiliary mutable variable, the body of the function defines a variable sums to hold a list of all partial sums of elements of the original list. The first element is defined to be zero and each of the following elements is defined as the sum of the current element of the new list and the next element of the original list. Recursion in the local definition is allowed by the keyword rec . The last line of the body of the function returns the last element of the new list which contains precisely the total sum of elements of the original list.","title":"Recursive definition of an auxiliary list"},{"location":"1-user-guide/1-getting-started/#calling-the-library-function","text":"The standard library of ZK-SecreC contains a function sum that finds the total sum of its argument list. Hence it suffices to import the corresponding module Std . For that, the following code line has to be added to the file summation.zksc : use Std::*; This library module also defines the type synonym u64 to denote the type uint[0x10000000000000000] . Hence, when using Std , there is no need to define M in the program, and the type uint[M] can be replaced with u64 .","title":"Calling the library function"},{"location":"1-user-guide/1-getting-started/#output","text":"To compile the program we might run runrust summation.zksc -p public.json -i instance.json -w witness.json -o result All three variants lead to output files (relation description, verifier's input stream, and prover's input stream) with the following contents: // File result.rel version 2.1.0; circuit; @type field 1030307; @begin $0 <- @public(0); $1 <- @public(0); $2 <- @public(0); $3 <- @public(0); $4 <- @public(0); $5 <- @public(0); $6 <- @public(0); $7 <- @private(0); $8 <- @addc(0: $0, <0>); $9 <- @add(0: $8, $1); $10 <- @add(0: $9, $2); $11 <- @add(0: $10, $3); $12 <- @add(0: $11, $4); $13 <- @add(0: $12, $5); $14 <- @add(0: $13, $6); $15 <- @mulc(0: $7, <1030306>); $16 <- @add(0: $14, $15); @assert_zero(0: $16); @end // File result_0.ins version 2.1.0; public_input; @type field 1030307; @begin <11>; <22>; <33>; <44>; <55>; <66>; <77>; @end // File result_0.wit version 2.1.0; private_input; @type field 1030307; @begin <308>; @end","title":"Output"},{"location":"1-user-guide/1-getting-started/#a-more-serious-example-of-factorization","text":"In the initial factorization example, the prover might have submitted 1 and 96 as factors of 96 and the proof would still have been successful. Let's study how to update the program in such a way that only non-trivial factorizations would be accepted. This requires checking that neither of the factors is one. Moreover, the initial example allowed the prover to misuse overflow, i.e., cheat by providing two numbers whose product were equal to the verifier's number in the finite field but not in integers. In order to eliminate this possibility, size checks must be added. It is safe to assert that both factor candidates can be represented using less than half of the number of bits in the binary representation of the field size. This excludes overflow when the numbers are multiplied. The following program would work: use Std::*; use Integer::*; use Inequalities::*; type N : Nat = 3647104749702663936044671300410017453855276508776292262406172562348790436137984035021; fn main() where Field[N] { let z : uint[N] $post @verifier = wire { get_instance(\"z\") }; let x : uint[N] $post @prover = wire { get_witness(\"x\") }; let y = wire { z as @prover as $pre / x as $pre }; assert(!eq(x, 1)); assert(!eq(y, 1)); let mut s = sizeasserter_new(((log2(N) - 1) / 2) as u64); let trash = check_size(x, ref s); let trash = check_size(y, ref s); assert_zero(x * y - z as @prover) } The first line of the body of main reads the number to be factorized and passes it to the circuit. The second line similarly reads one factor and passes it to the circuit. In the third line, the second input from the prover goes to the circuit. Instead of reading it from the prover's file, the code instructs the prover to compute this input as the ratio of the verifier's input and the prover's first input. This computation must be delegated outside the circuit as the circuit does not support division. Therefore the stage of the operands must be transformed by as $pre . Computing the second factor instead of reading it from the file is a non-essential change that makes the second factor formally an expanded witness, but it does not cause changes in the resulting prover's stream as the latter does not distinguish between witness and expanded witness. The fourth and fifth line assert that the factor candidates differ from 1. The built-in ZK-SecreC function assert requires a boolean argument and asserts it being true. The eq library function returns true if its two arguments are equal and false otherwise; the unary operator ! negates its boolean argument. This somewhat complicated sequence of operations is necessary since there is no assert_nonzero function. The next three lines deal with checking the size of the factor candidates. For that, a size asserter is created. A size asserter is an object that is able to check that binary representations of numbers fit into a fixed number of bits. The number of bits is given as argument when creating the object. Here, the argument is (log2(N) - 1) / 2 where log2 is the library function that returns the floor of binary logarithm of its argument; note that ZK-SecreC allows the programmer to use type level integers as values of type uint . The result must be cast to type u64 as this is the argument type of the function sizeasserter_new . The actual check is triggered by the library function check_size that takes as arguments the number whose size is checked and a size asserter. The let trash = is there because the result of check_size is not used (similarly to assertions, if the size check fails then the whole ZK proof fails). Note that the size asserter is assigned to a mutable variable, and it is also passed to the function check_size as mutable as indicated by the keyword ref . It is essential to make size asserters mutable since, for computational efficiency, they collect information about the checked numbers throughout the program, thus changing their value at every operation, and do all necessary checks together at the end of their life time. Finally, the last line of the body of main asserts that the product of the claimed factors is indeed equal to the number being factorized. The resulting files will be much larger than in the case of the first example. Therefore we will not present the contents of the resulting files. The body of the .rel file contains 1580 lines and the body of the .wit file contains 284 lines. The large size of witness is caused by library functions that expand the witness. Most of the size explosion is caused by operations with the size asserter (finding out binary representations requires input from the prover) but eq also has to expand witness since equality check along with returning of the result cannot be performed by the circuit alone.","title":"A more serious example of factorization"},{"location":"2-dev-guide/0-profiling/","text":"Profiling Profiling of generated Rust code The runrust script has a --flamegraph flag for generating flamegraphs of the execution time. This gives an overview of the execution time broken down by vertices of the call graph. While this does not perfectly reflect the number of IR gates generated by particular functions, it shows where the execution time goes. This setup has been tested on Ubuntu only (setup instructions below). Usage With appropriate setup the usage should be as simple as: $ ./runrust --flamegraph \\ docs/M27-electric-vehicle/ev-inf-mod.zksc \\ docs/M27-electric-vehicle/pentagon_inputs/public.json \\ docs/M27-electric-vehicle/pentagon_inputs/{instance,witness}_darpa_pentagon.json \\ -c docs/M27-electric-vehicle/ev-inf-mod.ccc -o opublic > /dev/null This call generates file src/Rust/flamegraph.svg that can be viewed with all modern browsers. Under linux, profile data are gathered with perf and the data are written to src/Rust/perf.data . This file can be further transformed and used by other tools like Firefox profiler . Make sure to have rustfilt installed. The following line also shortens generated functions names to strip the internal crate name and unique suffix: perf script -i src/Rust/perf.data | sed -E 's/zkscc_rust::generated::(.*)_u[[:digit:]]*/\\1/g' | rustfilt > zkscc_rust.perf The file zkscc_rust.perf can be directly loaded into the profile log viewer. Installing dependencies (Ubuntu) Install perf and other possible dependencies. Also modify the kernel.perf_event_paranoid setting to make sure that perf does not have to be run as root: sudo apt install linux-tools-common linux-tools-generic linux-tools-`uname -r` sudo sysctl -w kernel.kptr_restrict=0 sudo sysctl -w kernel.perf_event_paranoid=-1 To make these changes persist reboots, add a file /etc/sysctl.d/50-perf.conf with the following contents: kernel.kptr_restrict=0 kernel.perf_event_paranoid=-1 Make sure that cargo install directory (usually ~/.cargo/bin ) is found in $PATH . Install cargo-flamegraph as user: cargo install flamegraph Installing rustfilt is not necessary but it will help demangle function names to a more readable form: cargo install rustfilt Troubleshooting It's so slow! The overhead should be less than twice in time. The issue might be that perf shipped with Ubuntu can be very slow . The solution is to install perf shipped with kernel that is linked against libbfd. We start by installing various dependencies that might be used by perf : sudo apt install \\ flex \\ bison \\ libelf-dev \\ libaudit-dev \\ libdw-dev \\ libunwind-dev \\ python2-dev \\ binutils-dev \\ libnuma-dev \\ libgtk2.0-dev \\ libbfd-dev \\ libelf1 \\ libperl-dev \\ libnuma-dev \\ libslang2 libslang2-dev \\ libunwind8 libunwind8-dev \\ binutils-multiarch-dev \\ elfutils \\ libiberty-dev The following commands to install perf to ~/.local/bin is for my particular kernel version; substitute your own. sudo apt install linux-source cd <some working directory> cp /usr/src/linux-source-5.15.0/linux-source-5.15.0.tar.bz2 . tar xvfj linux-source-5.15.0.tar.bz2 cd linux-source-5.15.0/tools/perf make prefix=$HOME/.local install-bin Profiling the frontend Haskell code The simplest way to install the ZK-SecreC compiler frontend with profiling enabled is to invoke stack with appropriate profiling flag: $ stack install --profile By default, this installs ZK-SecreC compiler frontend with profiling enabled to ~/.local/bin directory. Make sure that this directory is found in PATH environment variable. In order to make the compiler produce profiling output, appropriate flags must be passed to the Haskell run time system (RTS). For example, to obtain regular profiling output we must add flag +RTS -p to the original command line call. After calling $ zkscc <regular options> +RTS -p profiling output will be written to a human readable file zkscc.prof . Heap profiling output is produced with flag -h : $ zkscc <regular options> +RTS -h This produces a file zkscc.hp that must be converted to .ps format using hp2ps utility (should be bundled with GHC). Much more details about profiling Haskell programs with GHC can be found in the documentation of GHC .","title":"Profiling"},{"location":"2-dev-guide/0-profiling/#profiling","text":"","title":"Profiling"},{"location":"2-dev-guide/0-profiling/#profiling-of-generated-rust-code","text":"The runrust script has a --flamegraph flag for generating flamegraphs of the execution time. This gives an overview of the execution time broken down by vertices of the call graph. While this does not perfectly reflect the number of IR gates generated by particular functions, it shows where the execution time goes. This setup has been tested on Ubuntu only (setup instructions below).","title":"Profiling of generated Rust code"},{"location":"2-dev-guide/0-profiling/#usage","text":"With appropriate setup the usage should be as simple as: $ ./runrust --flamegraph \\ docs/M27-electric-vehicle/ev-inf-mod.zksc \\ docs/M27-electric-vehicle/pentagon_inputs/public.json \\ docs/M27-electric-vehicle/pentagon_inputs/{instance,witness}_darpa_pentagon.json \\ -c docs/M27-electric-vehicle/ev-inf-mod.ccc -o opublic > /dev/null This call generates file src/Rust/flamegraph.svg that can be viewed with all modern browsers. Under linux, profile data are gathered with perf and the data are written to src/Rust/perf.data . This file can be further transformed and used by other tools like Firefox profiler . Make sure to have rustfilt installed. The following line also shortens generated functions names to strip the internal crate name and unique suffix: perf script -i src/Rust/perf.data | sed -E 's/zkscc_rust::generated::(.*)_u[[:digit:]]*/\\1/g' | rustfilt > zkscc_rust.perf The file zkscc_rust.perf can be directly loaded into the profile log viewer.","title":"Usage"},{"location":"2-dev-guide/0-profiling/#installing-dependencies-ubuntu","text":"Install perf and other possible dependencies. Also modify the kernel.perf_event_paranoid setting to make sure that perf does not have to be run as root: sudo apt install linux-tools-common linux-tools-generic linux-tools-`uname -r` sudo sysctl -w kernel.kptr_restrict=0 sudo sysctl -w kernel.perf_event_paranoid=-1 To make these changes persist reboots, add a file /etc/sysctl.d/50-perf.conf with the following contents: kernel.kptr_restrict=0 kernel.perf_event_paranoid=-1 Make sure that cargo install directory (usually ~/.cargo/bin ) is found in $PATH . Install cargo-flamegraph as user: cargo install flamegraph Installing rustfilt is not necessary but it will help demangle function names to a more readable form: cargo install rustfilt","title":"Installing dependencies (Ubuntu)"},{"location":"2-dev-guide/0-profiling/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"2-dev-guide/0-profiling/#its-so-slow","text":"The overhead should be less than twice in time. The issue might be that perf shipped with Ubuntu can be very slow . The solution is to install perf shipped with kernel that is linked against libbfd. We start by installing various dependencies that might be used by perf : sudo apt install \\ flex \\ bison \\ libelf-dev \\ libaudit-dev \\ libdw-dev \\ libunwind-dev \\ python2-dev \\ binutils-dev \\ libnuma-dev \\ libgtk2.0-dev \\ libbfd-dev \\ libelf1 \\ libperl-dev \\ libnuma-dev \\ libslang2 libslang2-dev \\ libunwind8 libunwind8-dev \\ binutils-multiarch-dev \\ elfutils \\ libiberty-dev The following commands to install perf to ~/.local/bin is for my particular kernel version; substitute your own. sudo apt install linux-source cd <some working directory> cp /usr/src/linux-source-5.15.0/linux-source-5.15.0.tar.bz2 . tar xvfj linux-source-5.15.0.tar.bz2 cd linux-source-5.15.0/tools/perf make prefix=$HOME/.local install-bin","title":"It's so slow!"},{"location":"2-dev-guide/0-profiling/#profiling-the-frontend-haskell-code","text":"The simplest way to install the ZK-SecreC compiler frontend with profiling enabled is to invoke stack with appropriate profiling flag: $ stack install --profile By default, this installs ZK-SecreC compiler frontend with profiling enabled to ~/.local/bin directory. Make sure that this directory is found in PATH environment variable. In order to make the compiler produce profiling output, appropriate flags must be passed to the Haskell run time system (RTS). For example, to obtain regular profiling output we must add flag +RTS -p to the original command line call. After calling $ zkscc <regular options> +RTS -p profiling output will be written to a human readable file zkscc.prof . Heap profiling output is produced with flag -h : $ zkscc <regular options> +RTS -h This produces a file zkscc.hp that must be converted to .ps format using hp2ps utility (should be bundled with GHC). Much more details about profiling Haskell programs with GHC can be found in the documentation of GHC .","title":"Profiling the frontend Haskell code"},{"location":"3-reference/0-values-and-types/","text":"Values and Types This section provides an informal introduction to the basic concepts of ZK-SecreC programming language. The syntax is described in later sections. A more detailed introduction to the type and effect system of ZK-SecreC is provided later. Qualifiers All values of ZK-SecreC are divided into clearly delimited data types. In this sense, ZK-SecreC is similar to a strongly typed programming language. Unlike usual programming languages, ZK-SecreC types involve qualifiers related to reliability and privacy of the data in the type. All data within the same type must have the same qualifiers, hence qualifiers are indeed attributes of type. Each non-functional data type is equipped with two qualifiers called stage and domain . The first of them, the stage, determines if the values of the type belong to the circuit, or are local to a party or parties. A stage can be either pre , meaning the values being local, or post , meaning the values being on wires of the circuit. The second qualifier, the domain, determines which parties have access to the data. Possible domains are prover , verifier and public . Data in the prover domain are visible to the prover only. Data in the verifier domain are visible to both the prover and the verifier. Data in the public domain are known during the compile time. ZK-SecreC defines a linear subtyping order on domains, the public domain being the lowest and the prover domain being the highest. It reflects the idea of increasing privacy. All data known to the verifier can be revealed to the prover but not vice versa. All data in the public domain, i.e. that are known to ZK-SecreC compiler, are available to both the verifier and the prover, while the verifier's and the prover's data are not available to the ZK-SecreC compiler. One purpose of the type system of ZK-SecreC is preventing leakage of private data, i.e, guaranteeing that data in higher domains will not become available in lower domains during computation. Somewhat analogously, ZK-SecreC observes a subtyping order also on stages, defining the post stage as lower than the pre stage. This reflects the idea of decreasing reliability (i.e., larger in the order means less reliable). A reliable piece of data becoming available in the less reliable world makes no harm, but the converse is not true. Since circuit outcome decides the result of the ZK proof, data in the circuit used for computing must be reliable. A local computation is performed by parties and is not guaranteed to follow the ZK-SecreC program, hence its outcome is unreliable. However in practice, we consider data in the pre stage of the public and the verifier domains also reliable, because we postulate that only the prover might be motivated to cheat. Most of ZK proofs make use of expanded witnesses, i.e., additional data inputs given to the circuit by the prover. Hence moving data from the pre stage to the post stage must nevertheless be allowed, violating the subtyping order. ZK-SecreC provides no guarantees of maintaining reliability of the data in the circuit. It is up to the programmer to apply all checks necessary to ensure that the data in the circuit originally provided by the prover could not be fake. When not clear from the context, types equipped with qualifiers are called qualified types , while types without qualifiers are called unqualified types . Primitive data Integers and field elements An arithmetic circuit is assumed to compute on non-negative integers less than a fixed prime number. Overflows and underflows (i.e., negative numbers) are resolved modulo the prime number. This way, operations in the circuit and values on wires can be interpreted as operations of a finite field and field elements, respectively. More precisely, the underlying computing model can actually include multiple arithmetic circuits, each using its own modulus. ZK-SecreC has a bounded integer type for each prime number to accommodate computations in such circuits. Strictly speaking, ZK-SecreC does not check primality of the module, but the standard library of ZK-SecreC is written with the assumption that all moduli of computations on wires are prime numbers. All integer types with a prime modulus can be used with both the pre stage and the post stage, as well as with all three domains. At the pre stage, it is allowed to use computations with any (prime or composite) modulus. Loop indices and list lengths must be integers with modulus 2 64 . In addition, ZK-SecreC has an unbounded integer type that contains all non-negative, as well as negative integers. These integers can also be used at the pre stage only, in all three domains. Booleans ZK-SecreC supports booleans. For maintaining ability to translate booleans to circuit values, a boolean type can be equipped with a modulus, too. All boolean types contain just two values, true and false. Like integer types, booleans with prime modulus can be used at both the pre stage and the post stage, as well as in all three domains. Booleans with a composite modulus and booleans without a modulus can be used at the pre stage, in all three domains. Unit There is a unit type consisting of just one value. ZK-SecreC uses the unit type as the formal return type of functions that return no meaningful value. The unit type is always qualified with the pre stage because the single unit value is not used by the circuit. Data structures Tuples A tuple is a finite sequence of values of possibly different types. For every finite sequence of qualified types, there is an unqualified type of tuples of components having these types (in the corresponding order). The number of elements is thus reflected by the type. Tuple types are always qualified with the pre stage. Tuple components can be accessed by name. The name of each component is the decimal representation of its index. Component indexing starts from zero. Structs Like a tuple, a struct is a finite sequence of values of possibly different types and the number of struct components is fixed by the type. Unlike in the case of tuples, the struct type and the struct components have names chosen by the programmer. Struct components can be accessed by these component names. The component names are also determined by the type. Lists A list is a finite sequence of values of one and the same qualified type. The element type being qualified implies that all elements of any list must have the same stage and domain, not just the same type of data. The length (i.e., the number of elements) is a non-negative integer that is not determined by the type and does not have to be known to the compiler. Lists can be accessed by index, this is the most standard method of accessing list elements. But one can also append new elements to the end of a given list. There is an unqualified list type of every qualified element type. This way, a list type can be given qualifiers other than those of the element type. In particular, the domain of a list is the domain where the structure of the list is known, which may differ from the domain where the elements of the list are known. As any list has a linear shape, the only piece of information provided by the structure of the list is its length. All lists are at the pre stage since the circuit does not deal with the list structure. Vectors A vector is also a finite sequence of values of one and the same qualified type. Similarly to lists, the length of a vector is not determined by the type. Like lists, vectors can be accessed by index. Unlike lists, vectors are compiled into consecutive wire ranges in the circuit and are supposed to be processed in ways that take advantage of the special memory allocation. Also unlike the case of lists, one cannot append new elements to vectors. Vector types are parametrized and qualified similarly to list types. Tensors A tensor is a special form of a vector that can have 1 or more dimensions. It has the same type as a vector. The number of dimensions is not part of the type, it is determined at runtime. An ordinary vector is considered as a 1-dimensional tensor. A tensor has a fixed length in each dimension. This is in contrast with lists of lists, where each element list can have a different length. The shape of an n -dimensional tensor is a list of n integers [ m 1 ,..., m n ], where m i is the length in the i th dimension. The total number of elements in this tensor is m 1 \u22c5...\u22c5 m n . Stores ZK-SecreC also supports dictionaries called stores . Currently, only integers are accepted as keys and values. Both keys and values of stores must have the same stage and the same domain. In the past versions of ZK-SecreC, all stores were builtin. Now, stores in the post stage are defined as structs in the standard library but their implementation still relies on builtin stores in the pre stage. Functions ZK-SecreC supports functions like most programming languages. Functions in ZK-SecreC can have one or more arguments and must have exactly one return value. The types of the arguments and the type of the return value together form the type of the function. If a function with no arguments or no return value is wanted then the unit type can be used as placeholder. Each argument type and the result type of a first-order non-curried function must be a qualified type. ZK-SecreC also supports higher-order functions, i.e., functions whose arguments are functions, and curried functions, i.e., functions whose result value is a function.","title":"Values and Types"},{"location":"3-reference/0-values-and-types/#values-and-types","text":"This section provides an informal introduction to the basic concepts of ZK-SecreC programming language. The syntax is described in later sections. A more detailed introduction to the type and effect system of ZK-SecreC is provided later.","title":"Values and Types"},{"location":"3-reference/0-values-and-types/#qualifiers","text":"All values of ZK-SecreC are divided into clearly delimited data types. In this sense, ZK-SecreC is similar to a strongly typed programming language. Unlike usual programming languages, ZK-SecreC types involve qualifiers related to reliability and privacy of the data in the type. All data within the same type must have the same qualifiers, hence qualifiers are indeed attributes of type. Each non-functional data type is equipped with two qualifiers called stage and domain . The first of them, the stage, determines if the values of the type belong to the circuit, or are local to a party or parties. A stage can be either pre , meaning the values being local, or post , meaning the values being on wires of the circuit. The second qualifier, the domain, determines which parties have access to the data. Possible domains are prover , verifier and public . Data in the prover domain are visible to the prover only. Data in the verifier domain are visible to both the prover and the verifier. Data in the public domain are known during the compile time. ZK-SecreC defines a linear subtyping order on domains, the public domain being the lowest and the prover domain being the highest. It reflects the idea of increasing privacy. All data known to the verifier can be revealed to the prover but not vice versa. All data in the public domain, i.e. that are known to ZK-SecreC compiler, are available to both the verifier and the prover, while the verifier's and the prover's data are not available to the ZK-SecreC compiler. One purpose of the type system of ZK-SecreC is preventing leakage of private data, i.e, guaranteeing that data in higher domains will not become available in lower domains during computation. Somewhat analogously, ZK-SecreC observes a subtyping order also on stages, defining the post stage as lower than the pre stage. This reflects the idea of decreasing reliability (i.e., larger in the order means less reliable). A reliable piece of data becoming available in the less reliable world makes no harm, but the converse is not true. Since circuit outcome decides the result of the ZK proof, data in the circuit used for computing must be reliable. A local computation is performed by parties and is not guaranteed to follow the ZK-SecreC program, hence its outcome is unreliable. However in practice, we consider data in the pre stage of the public and the verifier domains also reliable, because we postulate that only the prover might be motivated to cheat. Most of ZK proofs make use of expanded witnesses, i.e., additional data inputs given to the circuit by the prover. Hence moving data from the pre stage to the post stage must nevertheless be allowed, violating the subtyping order. ZK-SecreC provides no guarantees of maintaining reliability of the data in the circuit. It is up to the programmer to apply all checks necessary to ensure that the data in the circuit originally provided by the prover could not be fake. When not clear from the context, types equipped with qualifiers are called qualified types , while types without qualifiers are called unqualified types .","title":"Qualifiers"},{"location":"3-reference/0-values-and-types/#primitive-data","text":"","title":"Primitive data"},{"location":"3-reference/0-values-and-types/#integers-and-field-elements","text":"An arithmetic circuit is assumed to compute on non-negative integers less than a fixed prime number. Overflows and underflows (i.e., negative numbers) are resolved modulo the prime number. This way, operations in the circuit and values on wires can be interpreted as operations of a finite field and field elements, respectively. More precisely, the underlying computing model can actually include multiple arithmetic circuits, each using its own modulus. ZK-SecreC has a bounded integer type for each prime number to accommodate computations in such circuits. Strictly speaking, ZK-SecreC does not check primality of the module, but the standard library of ZK-SecreC is written with the assumption that all moduli of computations on wires are prime numbers. All integer types with a prime modulus can be used with both the pre stage and the post stage, as well as with all three domains. At the pre stage, it is allowed to use computations with any (prime or composite) modulus. Loop indices and list lengths must be integers with modulus 2 64 . In addition, ZK-SecreC has an unbounded integer type that contains all non-negative, as well as negative integers. These integers can also be used at the pre stage only, in all three domains.","title":"Integers and field elements"},{"location":"3-reference/0-values-and-types/#booleans","text":"ZK-SecreC supports booleans. For maintaining ability to translate booleans to circuit values, a boolean type can be equipped with a modulus, too. All boolean types contain just two values, true and false. Like integer types, booleans with prime modulus can be used at both the pre stage and the post stage, as well as in all three domains. Booleans with a composite modulus and booleans without a modulus can be used at the pre stage, in all three domains.","title":"Booleans"},{"location":"3-reference/0-values-and-types/#unit","text":"There is a unit type consisting of just one value. ZK-SecreC uses the unit type as the formal return type of functions that return no meaningful value. The unit type is always qualified with the pre stage because the single unit value is not used by the circuit.","title":"Unit"},{"location":"3-reference/0-values-and-types/#data-structures","text":"","title":"Data structures"},{"location":"3-reference/0-values-and-types/#tuples","text":"A tuple is a finite sequence of values of possibly different types. For every finite sequence of qualified types, there is an unqualified type of tuples of components having these types (in the corresponding order). The number of elements is thus reflected by the type. Tuple types are always qualified with the pre stage. Tuple components can be accessed by name. The name of each component is the decimal representation of its index. Component indexing starts from zero.","title":"Tuples"},{"location":"3-reference/0-values-and-types/#structs","text":"Like a tuple, a struct is a finite sequence of values of possibly different types and the number of struct components is fixed by the type. Unlike in the case of tuples, the struct type and the struct components have names chosen by the programmer. Struct components can be accessed by these component names. The component names are also determined by the type.","title":"Structs"},{"location":"3-reference/0-values-and-types/#lists","text":"A list is a finite sequence of values of one and the same qualified type. The element type being qualified implies that all elements of any list must have the same stage and domain, not just the same type of data. The length (i.e., the number of elements) is a non-negative integer that is not determined by the type and does not have to be known to the compiler. Lists can be accessed by index, this is the most standard method of accessing list elements. But one can also append new elements to the end of a given list. There is an unqualified list type of every qualified element type. This way, a list type can be given qualifiers other than those of the element type. In particular, the domain of a list is the domain where the structure of the list is known, which may differ from the domain where the elements of the list are known. As any list has a linear shape, the only piece of information provided by the structure of the list is its length. All lists are at the pre stage since the circuit does not deal with the list structure.","title":"Lists"},{"location":"3-reference/0-values-and-types/#vectors","text":"A vector is also a finite sequence of values of one and the same qualified type. Similarly to lists, the length of a vector is not determined by the type. Like lists, vectors can be accessed by index. Unlike lists, vectors are compiled into consecutive wire ranges in the circuit and are supposed to be processed in ways that take advantage of the special memory allocation. Also unlike the case of lists, one cannot append new elements to vectors. Vector types are parametrized and qualified similarly to list types.","title":"Vectors"},{"location":"3-reference/0-values-and-types/#tensors","text":"A tensor is a special form of a vector that can have 1 or more dimensions. It has the same type as a vector. The number of dimensions is not part of the type, it is determined at runtime. An ordinary vector is considered as a 1-dimensional tensor. A tensor has a fixed length in each dimension. This is in contrast with lists of lists, where each element list can have a different length. The shape of an n -dimensional tensor is a list of n integers [ m 1 ,..., m n ], where m i is the length in the i th dimension. The total number of elements in this tensor is m 1 \u22c5...\u22c5 m n .","title":"Tensors"},{"location":"3-reference/0-values-and-types/#stores","text":"ZK-SecreC also supports dictionaries called stores . Currently, only integers are accepted as keys and values. Both keys and values of stores must have the same stage and the same domain. In the past versions of ZK-SecreC, all stores were builtin. Now, stores in the post stage are defined as structs in the standard library but their implementation still relies on builtin stores in the pre stage.","title":"Stores"},{"location":"3-reference/0-values-and-types/#functions","text":"ZK-SecreC supports functions like most programming languages. Functions in ZK-SecreC can have one or more arguments and must have exactly one return value. The types of the arguments and the type of the return value together form the type of the function. If a function with no arguments or no return value is wanted then the unit type can be used as placeholder. Each argument type and the result type of a first-order non-curried function must be a qualified type. ZK-SecreC also supports higher-order functions, i.e., functions whose arguments are functions, and curried functions, i.e., functions whose result value is a function.","title":"Functions"},{"location":"3-reference/1-lexical-structure/","text":"Lexical Structure Lexemes are recognized as the longest sequences of characters matching a token description. If one wants two lexemes that would be interpreted as one when written one after another, they must be separated by whitespace. Whitespace <whitespace> ::= <whitechr>+ <whitechr> ::= | \\n | \\r | \\f | \\t | \\v | <unispace> Legal whitespaces of ZK-SecreC consist of one or more whitespace characters. Blank space, line feed, carridge return, form feed, tab and vertical tab are interpreted as whitespace characters. In addition, every Unicode space character fits. Comments ZK-SecreC supports line comments and block comments. Line comments start with two slashes ( // ) and end with a line break. Block comments are opened with /* and closed with */ . Block comments can be nested. Names Identifiers <varid> ::= <idfirst> <idother>* <idfirst> ::= <large> | <small> <idother> ::= <idfirst> | <digit> | ' <large> ::= <asclarge> | <unilarge> <asclarge> ::= [A-Z] <small> ::= _ | <ascsmall> | <unismall> <ascsmall> ::= [a-z] <digit> ::= <decdigit> | <unidigit> <decdigit> ::= [0-9] An identifier is a Unicode string that can contain alphanumeric characters, decimal digits, underscores and apostrophes. Identifiers must begin with an alphanumeric character or an underscore. Operators ZK-SecreC allows defining new operators. Operators consist of one or more characters in the following supply: !#$%&*+/<=>?@\\^|-~ Special character sequences Some character sequences are reserved for special purposes and cannot be used as names of user-defined identifiers or operators. Keywords ZK-SecreC has the following keywords: _ arr as bool break Challenge continue Convertible dbg_assert_eq dbg_assert default Domain eff else ExtendedArithmetic extern false Field fn for forall if impl in inf infix infixl infixr let list mut Nat PermuatationCheck post pre prover pub public Qualified rec ref return self Self sieve store Stage string struct trace true tuple type uint unchecked unit Unqualified use Vectors Vectorization verifier where while wire with witness zip Keywords self and Self have no purpose in the current version of the language. They are reserved for prospective future extensions. Keyword witness is no more used in the language but it is still reserved for giving a proper error message in case it is used in a program. Special symbol sequences There are also symbol sequences that cannot be used as operators since they have other meaning in ZK-SecreC programs: -> => @ $ ; :: : , = Symbol sequences + , * , <= , ! also have predefined meaning but still serve as builtin operators. In addition, special symbol sequences . and .. are used in ZK-SecreC. Parentheses The following symbol sequences are used as opening delimiters: ( .( [ { {# {## Closing delimiters always consist of a single symbol: ) ] } When matching the delimiters, all symbols in the opening delimiter other than parentheses are ignored. For instance, { ... .( ... {# ... } ... [ ... ] ... ) ... } has balanced delimiters (assuming that there are no delimiters other than those explicitly shown): Delimiters 1 and 2 match with delimiters 8 and 7, respectively, whereas delimiters 3 and 4 match each other and delimiters 5 and 6 match each other. Literals Unsigned integer literals Unsigned integer literals can be written as binary, octal, decimal or hexadecimal numbers. Binary, octal and hexadecimal numbers must start with corresponding prefix: Prefix Radix 0b binary 0o octal 0x hexadecimal Binary, octal and decimal numbers are written using the usual digit characters. Hexadecimal numbers can also contain letters a-f, either capitalized or not. An integer literal may contain any positive number of digits. Boolean literals There are two built-in boolean literals: true and false . String literals String literals are delimited by the double quote ( \" ) characters. Any double quote characters within the string must be escaped by a backslash character. A backslash itself must be escaped, too. One can use \\n and \\t to encode the newline and the tabular character, respectively. It is also allowed to encode characters via their ASCII/Unicode codes in decimal like in \\65 , as well as in binary, octal or hexadecimal notation like in \\b1000001 , \\o101 and \\x41 .","title":"Lexical Structure"},{"location":"3-reference/1-lexical-structure/#lexical-structure","text":"Lexemes are recognized as the longest sequences of characters matching a token description. If one wants two lexemes that would be interpreted as one when written one after another, they must be separated by whitespace.","title":"Lexical Structure"},{"location":"3-reference/1-lexical-structure/#whitespace","text":"<whitespace> ::= <whitechr>+ <whitechr> ::= | \\n | \\r | \\f | \\t | \\v | <unispace> Legal whitespaces of ZK-SecreC consist of one or more whitespace characters. Blank space, line feed, carridge return, form feed, tab and vertical tab are interpreted as whitespace characters. In addition, every Unicode space character fits.","title":"Whitespace"},{"location":"3-reference/1-lexical-structure/#comments","text":"ZK-SecreC supports line comments and block comments. Line comments start with two slashes ( // ) and end with a line break. Block comments are opened with /* and closed with */ . Block comments can be nested.","title":"Comments"},{"location":"3-reference/1-lexical-structure/#names","text":"","title":"Names"},{"location":"3-reference/1-lexical-structure/#identifiers","text":"<varid> ::= <idfirst> <idother>* <idfirst> ::= <large> | <small> <idother> ::= <idfirst> | <digit> | ' <large> ::= <asclarge> | <unilarge> <asclarge> ::= [A-Z] <small> ::= _ | <ascsmall> | <unismall> <ascsmall> ::= [a-z] <digit> ::= <decdigit> | <unidigit> <decdigit> ::= [0-9] An identifier is a Unicode string that can contain alphanumeric characters, decimal digits, underscores and apostrophes. Identifiers must begin with an alphanumeric character or an underscore.","title":"Identifiers"},{"location":"3-reference/1-lexical-structure/#operators","text":"ZK-SecreC allows defining new operators. Operators consist of one or more characters in the following supply: !#$%&*+/<=>?@\\^|-~","title":"Operators"},{"location":"3-reference/1-lexical-structure/#special-character-sequences","text":"Some character sequences are reserved for special purposes and cannot be used as names of user-defined identifiers or operators.","title":"Special character sequences"},{"location":"3-reference/1-lexical-structure/#keywords","text":"ZK-SecreC has the following keywords: _ arr as bool break Challenge continue Convertible dbg_assert_eq dbg_assert default Domain eff else ExtendedArithmetic extern false Field fn for forall if impl in inf infix infixl infixr let list mut Nat PermuatationCheck post pre prover pub public Qualified rec ref return self Self sieve store Stage string struct trace true tuple type uint unchecked unit Unqualified use Vectors Vectorization verifier where while wire with witness zip Keywords self and Self have no purpose in the current version of the language. They are reserved for prospective future extensions. Keyword witness is no more used in the language but it is still reserved for giving a proper error message in case it is used in a program.","title":"Keywords"},{"location":"3-reference/1-lexical-structure/#special-symbol-sequences","text":"There are also symbol sequences that cannot be used as operators since they have other meaning in ZK-SecreC programs: -> => @ $ ; :: : , = Symbol sequences + , * , <= , ! also have predefined meaning but still serve as builtin operators. In addition, special symbol sequences . and .. are used in ZK-SecreC.","title":"Special symbol sequences"},{"location":"3-reference/1-lexical-structure/#parentheses","text":"The following symbol sequences are used as opening delimiters: ( .( [ { {# {## Closing delimiters always consist of a single symbol: ) ] } When matching the delimiters, all symbols in the opening delimiter other than parentheses are ignored. For instance, { ... .( ... {# ... } ... [ ... ] ... ) ... } has balanced delimiters (assuming that there are no delimiters other than those explicitly shown): Delimiters 1 and 2 match with delimiters 8 and 7, respectively, whereas delimiters 3 and 4 match each other and delimiters 5 and 6 match each other.","title":"Parentheses"},{"location":"3-reference/1-lexical-structure/#literals","text":"","title":"Literals"},{"location":"3-reference/1-lexical-structure/#unsigned-integer-literals","text":"Unsigned integer literals can be written as binary, octal, decimal or hexadecimal numbers. Binary, octal and hexadecimal numbers must start with corresponding prefix: Prefix Radix 0b binary 0o octal 0x hexadecimal Binary, octal and decimal numbers are written using the usual digit characters. Hexadecimal numbers can also contain letters a-f, either capitalized or not. An integer literal may contain any positive number of digits.","title":"Unsigned integer literals"},{"location":"3-reference/1-lexical-structure/#boolean-literals","text":"There are two built-in boolean literals: true and false .","title":"Boolean literals"},{"location":"3-reference/1-lexical-structure/#string-literals","text":"String literals are delimited by the double quote ( \" ) characters. Any double quote characters within the string must be escaped by a backslash character. A backslash itself must be escaped, too. One can use \\n and \\t to encode the newline and the tabular character, respectively. It is also allowed to encode characters via their ASCII/Unicode codes in decimal like in \\65 , as well as in binary, octal or hexadecimal notation like in \\b1000001 , \\o101 and \\x41 .","title":"String literals"},{"location":"3-reference/2-type-level-expressions/","text":"Type Level Expressions In this section, the syntax that is used for expressing types and kinds in ZK-SecreC is described. Unqualified types Bounded integer types are written in the form uint[ N ] where N is either an integer literal or a type level variable (type synonym). The value of N is the modulus that bounds the values of this type. The unbounded integer type is written as uint . Similarly, bounded boolean types are written in the form bool[ N ] , with the same restriction imposed to N , and the unbounded boolean type is written as bool . Note that, internally, ZK-SecreC handles unbounded types as bounded by infinity. This sometimes reflects in the error messages. For example, an error message Unsolved constraints: inf ~ 1030307 means that an expression of the unbounded integer or boolean type was used where type uint[1030307] or bool[1030307] was expected (or vice versa). The string type is denoted as string . The unit type is denoted as () . These types do not depend on a modulus. For any qualified type q , the list type and vector type with elements of type q are written as list[ q ] and arr[ q ] , respectively. Whenever q 1 ,..., q n are qualified types, tuple[ q 1 , ... , q n ] denotes the tuple type with component types q 1 , ..., q n . Struct types are expressed via their names, along with a comma-separated list of type arguments in brackets if necessary. Although in the signature of a function, arguments are written in the form of a comma-separated sequence, the type of the function is treated as that of the curried form. For instance, a function that assumes two arguments of type q and returns a value of type r has type q \u2192 q \u2192 r . Qualified types For easy distinguishing, stage qualifiers are prefixed by the dollar sign. So the pre stage and the post stage are denoted by $pre and $post , respectively. Similarly, domain qualifiers are prefixed by the at sign. So the possible domains are written as @prover , @verifier and @public . A qualified type is denoted by a triple where the stage and the domain qualifier (in this order) follow the unqualified type. No commas or delimiters are used. For example, list[uint[1030307] $post @prover] $pre @public stands for the type of lists of elements of the finite field of size 1030307 in the circuit, originated from the prover, whereby the list structure is known to the compiler (public). Domains can interact with stages in ways that can initially be unintuitive. For example, lists with elements in the stage $post must be in the domain @public because list elements occur in the circuit, each on its own wire, and the number of wires is publicly visible. For similar reason, loops that produce values in the stage $post must have loop bounds in the domain @public . In general, all operations with values in the stage $post appear on the relation and the size of the relation should only depend on the program and public constants. More precise information can be found in the Type System subsection of this documentation. ZK-SecreC allows omitting one qualifier or both from a type expression while maintaining its meaning as a fully qualified type. If the stage qualifier is omitted then it is inferred, whereas an omitted domain qualifier is assumed to be @public . For instance, type expression list[uint[1030307] $post @prover] denotes the same qualified list type as the one above since lists are qualified by $pre ineluctably and @public coincides with the default domain qualifier. Variables ZK-SecreC allows types and functions to have type parameters. Global type level variables (type synonyms) can also be defined. By convention, names of type level variables are capitalized. Names of variables that denote a stage or a domain are prefixed by dollar and at, respectively. Application Application of a type level function to its arguments is written in standard way, the function followed by the arguments. Type arguments are written as a comma-separated list in brackets. Kinds Kinds are types of types. ZK-SecreC supports the following primitive kinds: Kind Types in the kind Nat Type-level natural numbers (including inf ) Stage $pre , $post Domain @prover , @verifier , @public Unqualified Unqualified types Qualified Qualified types Whenever k 1 and k 2 are kinds, k 1 \u2192 k 2 is the kind of type functions that map types of kind k 1 to types of kind k 2 . For instance, uint has kind Nat \u2192 Unqualified (recall that, internally, the unbounded integer type is expressed as uint[inf] ) and list has kind Qualified \u2192 Unqualified . Type predicates Type predicates establish properties of types. Type predicates can assume zero or more type arguments. Type predicates are used for imposing type-level restrictions within particular code fragments. Roughly, type predicates can be divided into three groups: Those that reflect a restriction originating from ZK requirements and agreements. For instance, <= at the type level is used for denoting the subtyping order of domains; so @public <= @prover reflects the fact that the prover domain has higher privacy than the public domain. Those that classify types according to some inherent structural property. For instance, the type predicate Array is true on type-level functions (of kind Qualified \u2192 Unqualified ) that construct types of linear-shaped data structures of elements of a fixed type (which is the argument of the function); more precisely, the type predicate Array holds for type-level functions list and arr . For another instance, the type predicate Sized holds on data types containing data of fixed size, i.e., primitive data types and types that contain tuples or structs of sized types (but not lists or vectors). Those that express assumptions whose validity or non-validity is established by the CCC file along with which the program is compiled. For instance, Field is a type predicate that holds if its argument type is a modulus that is allowed as a size of field by CCC. A program that requires such type predicates to hold may be type correct but still fail to compile if these requirements are not supported by CCC. ZK-SecreC has the following builtin type predicates: Type predicate Arity Group Meaning <= 2 1 subdomain relation pre 1 1 being $pre post 1 1 being $post Array 1 2 producing types of linear-shaped data structures of elements of a fixed type Sized 1 2 containing data of fixed size Field 1 3 being allowed as a field Challenge 1 3 challenge generation being allowed for the field Convertible 2 3 conversion from one field to another being allowed ObliviousChoice 0 3 the disjunction plugin of Circuit-IR being supported PermutationCheck 0 3 the permutation_check plugin of Circuit-IR being supported ExtendedArithmetic 0 3 the extended_arithmetic plugin of Circuit-IR being supported Vectors 0 3 the vectors plugin of Circuit-IR being supported Vectorization 0 3 operations taking advantage from wire ranges being used The Vectorization predicate is exceptional among the 0-ary predicates in the sense that its validity does not strictly need the presence of any Circuit-IR plugin. The predicate must be declared whenever some operations that involve vectors are used in the ZK-SecreC code, but the code can be compiled even if the iter plugin that provides vectorized operations is not supported. In such case, the operations with vectors are simply unrolled. ZK-SecreC does not support user-defined type predicates.","title":"Type Level Expressions"},{"location":"3-reference/2-type-level-expressions/#type-level-expressions","text":"In this section, the syntax that is used for expressing types and kinds in ZK-SecreC is described.","title":"Type Level Expressions"},{"location":"3-reference/2-type-level-expressions/#unqualified-types","text":"Bounded integer types are written in the form uint[ N ] where N is either an integer literal or a type level variable (type synonym). The value of N is the modulus that bounds the values of this type. The unbounded integer type is written as uint . Similarly, bounded boolean types are written in the form bool[ N ] , with the same restriction imposed to N , and the unbounded boolean type is written as bool . Note that, internally, ZK-SecreC handles unbounded types as bounded by infinity. This sometimes reflects in the error messages. For example, an error message Unsolved constraints: inf ~ 1030307 means that an expression of the unbounded integer or boolean type was used where type uint[1030307] or bool[1030307] was expected (or vice versa). The string type is denoted as string . The unit type is denoted as () . These types do not depend on a modulus. For any qualified type q , the list type and vector type with elements of type q are written as list[ q ] and arr[ q ] , respectively. Whenever q 1 ,..., q n are qualified types, tuple[ q 1 , ... , q n ] denotes the tuple type with component types q 1 , ..., q n . Struct types are expressed via their names, along with a comma-separated list of type arguments in brackets if necessary. Although in the signature of a function, arguments are written in the form of a comma-separated sequence, the type of the function is treated as that of the curried form. For instance, a function that assumes two arguments of type q and returns a value of type r has type q \u2192 q \u2192 r .","title":"Unqualified types"},{"location":"3-reference/2-type-level-expressions/#qualified-types","text":"For easy distinguishing, stage qualifiers are prefixed by the dollar sign. So the pre stage and the post stage are denoted by $pre and $post , respectively. Similarly, domain qualifiers are prefixed by the at sign. So the possible domains are written as @prover , @verifier and @public . A qualified type is denoted by a triple where the stage and the domain qualifier (in this order) follow the unqualified type. No commas or delimiters are used. For example, list[uint[1030307] $post @prover] $pre @public stands for the type of lists of elements of the finite field of size 1030307 in the circuit, originated from the prover, whereby the list structure is known to the compiler (public). Domains can interact with stages in ways that can initially be unintuitive. For example, lists with elements in the stage $post must be in the domain @public because list elements occur in the circuit, each on its own wire, and the number of wires is publicly visible. For similar reason, loops that produce values in the stage $post must have loop bounds in the domain @public . In general, all operations with values in the stage $post appear on the relation and the size of the relation should only depend on the program and public constants. More precise information can be found in the Type System subsection of this documentation. ZK-SecreC allows omitting one qualifier or both from a type expression while maintaining its meaning as a fully qualified type. If the stage qualifier is omitted then it is inferred, whereas an omitted domain qualifier is assumed to be @public . For instance, type expression list[uint[1030307] $post @prover] denotes the same qualified list type as the one above since lists are qualified by $pre ineluctably and @public coincides with the default domain qualifier.","title":"Qualified types"},{"location":"3-reference/2-type-level-expressions/#variables","text":"ZK-SecreC allows types and functions to have type parameters. Global type level variables (type synonyms) can also be defined. By convention, names of type level variables are capitalized. Names of variables that denote a stage or a domain are prefixed by dollar and at, respectively.","title":"Variables"},{"location":"3-reference/2-type-level-expressions/#application","text":"Application of a type level function to its arguments is written in standard way, the function followed by the arguments. Type arguments are written as a comma-separated list in brackets.","title":"Application"},{"location":"3-reference/2-type-level-expressions/#kinds","text":"Kinds are types of types. ZK-SecreC supports the following primitive kinds: Kind Types in the kind Nat Type-level natural numbers (including inf ) Stage $pre , $post Domain @prover , @verifier , @public Unqualified Unqualified types Qualified Qualified types Whenever k 1 and k 2 are kinds, k 1 \u2192 k 2 is the kind of type functions that map types of kind k 1 to types of kind k 2 . For instance, uint has kind Nat \u2192 Unqualified (recall that, internally, the unbounded integer type is expressed as uint[inf] ) and list has kind Qualified \u2192 Unqualified .","title":"Kinds"},{"location":"3-reference/2-type-level-expressions/#type-predicates","text":"Type predicates establish properties of types. Type predicates can assume zero or more type arguments. Type predicates are used for imposing type-level restrictions within particular code fragments. Roughly, type predicates can be divided into three groups: Those that reflect a restriction originating from ZK requirements and agreements. For instance, <= at the type level is used for denoting the subtyping order of domains; so @public <= @prover reflects the fact that the prover domain has higher privacy than the public domain. Those that classify types according to some inherent structural property. For instance, the type predicate Array is true on type-level functions (of kind Qualified \u2192 Unqualified ) that construct types of linear-shaped data structures of elements of a fixed type (which is the argument of the function); more precisely, the type predicate Array holds for type-level functions list and arr . For another instance, the type predicate Sized holds on data types containing data of fixed size, i.e., primitive data types and types that contain tuples or structs of sized types (but not lists or vectors). Those that express assumptions whose validity or non-validity is established by the CCC file along with which the program is compiled. For instance, Field is a type predicate that holds if its argument type is a modulus that is allowed as a size of field by CCC. A program that requires such type predicates to hold may be type correct but still fail to compile if these requirements are not supported by CCC. ZK-SecreC has the following builtin type predicates: Type predicate Arity Group Meaning <= 2 1 subdomain relation pre 1 1 being $pre post 1 1 being $post Array 1 2 producing types of linear-shaped data structures of elements of a fixed type Sized 1 2 containing data of fixed size Field 1 3 being allowed as a field Challenge 1 3 challenge generation being allowed for the field Convertible 2 3 conversion from one field to another being allowed ObliviousChoice 0 3 the disjunction plugin of Circuit-IR being supported PermutationCheck 0 3 the permutation_check plugin of Circuit-IR being supported ExtendedArithmetic 0 3 the extended_arithmetic plugin of Circuit-IR being supported Vectors 0 3 the vectors plugin of Circuit-IR being supported Vectorization 0 3 operations taking advantage from wire ranges being used The Vectorization predicate is exceptional among the 0-ary predicates in the sense that its validity does not strictly need the presence of any Circuit-IR plugin. The predicate must be declared whenever some operations that involve vectors are used in the ZK-SecreC code, but the code can be compiled even if the iter plugin that provides vectorized operations is not supported. In such case, the operations with vectors are simply unrolled. ZK-SecreC does not support user-defined type predicates.","title":"Type predicates"},{"location":"3-reference/3-expressions/","text":"Expressions Primitive expressions This subsection describes expressions that are primitive w.r.t. the Dijkstra shunting yard algorithm. This means that the structure within them does not affect parsing of parts of the expression outside of them. These parts may nevertheless have their own inner structure. Literals Integer literals can stand for values of any type uint[ N ] and also values of type uint , regardless of the stage and domain. If the number expressed by the literal equals or exceeds the modulus then the value of the literal equals the reminder of this number upon division by the modulus. Similarly, Boolean literals can stand for values of any type bool[ N ] and also values of type bool , regardless of the stage and domain. String literals can be in any of the three domains but the stage can be $pre only. Tuples, structs, stores The tuple of expressions e 1 , ..., e n , in this order, is written as ( e 1 , ... , e n ) . The value of the latter expression is the tuple of values of the component expressions, in the given order. New structs can be created by the expression S { x 1 : e 1 , ... , x 1 : e n } , where S is the name of the struct type, x 1 ,..., x n are names of fields in structs of this type, and e 1 ,..., e n are expressions. Every field that the struct type requires must occur in the expression. The value of this expression is the struct containing precisely all the named fields, the value of each field being the value of the subexpression corresponding to the name of the field. Since the time stores were first introduced into ZK-SecreC as a builtin feature, stores can be written using the delimiters {# ... } . Non-empty stores are written by providing some initial key-value pairs in the form {# k 1 => v 1 , ... , k n => v n } whereas empty stores are written as {#} . Here, both k i and v i may be any expressions. Although stores in the post stage are no more builtin, the old builtin store syntax is still usable for creating them. Stores in the pre stage can be created similarly using the delimiters {## ... } . Lists Lists with a known constant length can be created by expressions of the form [ e 1 , ... , e n ] . The value of this expression is the list whose elements are the values of expressions e 1 ,..., e n in this order. An empty list is written as [] . To create a new list whose all elements are equal, one can write an expression [ e ; n ] where e is an expression whose value is the repeating element and n is an expression whose value equals the number of repetitions. Parenthesized expressions Expressions in the form ( e ) where e is any expression evaluate to the same value as e . Compound expressions This subsection surveys expressions composed from smaller expressions using function and operator applications and other similar constructs. Operator application Expressions can be composed using unary and binary operators. In the case of builtin operators, predefined precedences are used to determine the right syntax tree of expressions. If another syntax tree is desired, subexpressions have to be parenthesized. For example, 1 + 2 * 3 is evaluated to 7 as multiplication binds tighter than addition, whereas (1 + 2) * 3 evaluates to 9 because now addition in parentheses is done before multiplication. If more than two subexpressions are connected by binary operators of the same precedence then the leftmost one takes precedence. Equality and comparisons are exceptions as applying them in sequence without specifying the order by parentheses is a syntax error. Currently, precedences do not work with user-defined operators. Hence one must show the order of operations with parentheses, except when only builtin operators are involved. Function applications Monomorphic function applications are written as expressions of the form f ( a 1 , ... , a n ) , where f is the name of the function and a 1 , ..., a n are the argument expressions. In a larger expression, function applications bind tighter than any unary or binary operator. Polymorphic functions usually can be called in the same way without specifying the actual type arguments, but if the actual type arguments cannot be inferred then they have to be specified before the ordinary argument sequence as a comma-separated list in brackets. The function identifier and the opening bracket must be separated by double colon. For instance, if the function sum assumes a stage and a domain as type level parameters like in the examples Getting Started and this function is called with an actual (data level) parameter xs that fixes the stage and domain to be $post and @verifier , respectively, then the programmer can make the type level arguments explicit by writing the call as sum::[$post,@verifier](xs) . Function arguments can be passed by value or by reference; the particular way is fixed for every function and its argument. An argument that is passed by value is written as just an expression whose value is to be passed to the function. A pass-by-reference argument must be preceded by keyword ref and it must be a mutable variable or a (direct or indirect) lookup into a mutable data structure. The function may change the value of such arguments in general. Pass-by-value parameters are immutable. Behind the scene, pass-by-value parameters may actually be passed by reference. Immutability guarantees that this does not change the semantics. So one may pass by value large data structures without the risk of wasting time and space for copying the data structure. The only difference between pass-by-value and pass-by-reference is the ability to mutate the parameter in the latter case. Functions that do not have pass-by-reference parameters are allowed to be applied partially. This means that one can provide less arguments than the function is able to take. The value of such expression is a function that can take the remaining arguments. A function with at least one pass-by-reference parameter cannot be applied partially. Vectorized applications ZK-SecreC allows the programmer to syntactically lift functions and operators to vectors. Vectorized application is identified by a period. For example, applying function f to arguments a 1 , ..., a n in vectorized way is denoted by f .( a 1 , ... , a n ) , i.e., using .( as the delimiter opening the sequence of arguments. The value of this expression is well defined only if the values of all argument expressions are vectors of identical length. Evaluation of the vectorized application produces a new vector of the same length by applying function f pointwise. To apply an operator in vectorized way, dot is written after the operator without space, e.g., the value of the expression x *. y is the pointwise product of the values of expressions x and y (provided that they are vectors of identical length). In addition to 1-dimensional vectors, vectorized applications can also be used with higher-dimensional tensors. In this case, a 1 ,..., a n must be tensors with the same shape and the result of the application also has this shape. If the iter plugin of Circuit-IR is supported by CCC then the compiler translates vectorized applications via the iter plugin operations. If the iter plugin is not supported, vectorized applications are compiled via unrolling. Assertions The assert builtin function is used to declare a new output node of the circuit. The assertion succeeds if the value of its argument is true. Similarly, assert_zero builtin function declares a new output node of the circuit. It succeeds if the value of its argument is zero. Both these functions must take its argument at the post stage. Besides these assertion functions, ZK-SecreC provides assertion functions dbg_assert and dbg_assert_eq without circuit output for debugging. The former assert succeeds if the value of its argument is true. The latter one assumes two arguments of integer types with possibly different modules and succeeds if the integer values (i.e., remainders upon division by the corresponding modules) are equal. These functions assume that their arguments are in the pre stage. These functions do not contribute to the circuit, but the program halts with an error message whenever any of these assertions fail. Builtin operators and functions The following builtin operators are available: Operators Arity Precedence Associativity Meaning ! 1 90 negation * / % 2 80 left product, quotient, remainder + - 2 70 left sum, difference <= >= < > 2 50 none comparisons == 2 40 none equality & 2 30 left conjunction ^ 2 20 left xor | 2 10 left disjunction The higher the precedence, the more tightly the operator binds its arguments. The builtin functions are described in the Builtins subsection of this documentation. Lookups and slices Components of tuples, structs and stores, as well as elements of lists and vectors, can be accessed using the corresponding lookup syntax. A tuple component can be accessed by index. The value of an expression of the form e . i , where e is an expression and i is an integer literal, is the i -th component of the tuple that e evaluates to. As the index must be a literal rather than an arbitrary expression, the compiler can decide if the index falls into the bounds required by the type of the tuple and give a static error otherwise. Indexing starts from zero. A struct component can be accessed with a similar syntax but using a field name instead of an index. The value of an expression of the form e . x , where e is an expression and x is a field name, is the component associated to the name x in the struct that e evaluates to. Again, the compiler can decide if the access is correct as available field names are determined by the struct type. Store elements can be accessed by expressions of the form e {# k } . Here, e and k are expressions whose values are the store and a key, respectively. An element in a list or vector can be accessed using its index in square brackets, i.e., with an expression of the form e [ i ] where e and i are expressions. Provided that the value of e is a list or vector and the value of i is a non-negative integer falling into the bounds of the list or vector, the value of the lookup expression is the corresponding element of the data structure. The compiler does not make sure that the index indeed falls between the bounds. If not, the computation halts abnormally. This is considered equivalent to ZK proof failure. ZK-SecreC allows using the square bracket syntax for extracting slices. To this end, one must specify a range of indices rather than a single index within brackets. The range is specified in terms of its lower bound and upper bound; the range contains all indices not less than the lower bound and less than the upper bound. The bounds of the range can be specified by any expressions and these expressions are separated by the double dot token. For example, e [ a .. b ] , where e , a and b are expressions, is a slice expression. Provided that the value of e is a list or vector and the values of both a and b are integers within the index bounds of the list or vector, the value of the slice expression is a new data structure of the same type as the original one (list or vector) and its elements are precisely the elements of the original data structure whose index falls into the range determined by the two integers (the first one being the lower bound). ZK-SecreC allows one to omit either of the two bounds. In this case, the corresponding bound is that of the original data structure. If both bounds are omitted, the result is a copy of the original data structure. A higher-dimensional tensor can also be sliced but only according to the first dimension as slicing by any other dimension would leave the elements on non-consecutive wires, which is not supported by Circuit-IR. Slicing an n -dimensional tensor uses the same syntax as vector slicing and returns another n -dimensional tensor. Assignments Assignment is denoted by = in ZK-SecreC. For instance, ix = ix + 1 increases the value of the variable ix by one. For a variable to be assigned to, it must be a mutable local variable or a pass-by-reference parameter of function. If a variable can be assigned to, and its value is whatever data structure except a vector, then its components, components of components etc., can be assigned to one by one if necessary. Such assignment uses the same notation as lookup. For instance, t.1 = 30 is syntactically correct, provided that t can be assigned to. For type correctness, the type of variable t must be a tuple type with at least 2 components, the second of which is an integer type. As the result, the value of t will be the same tuple as before with the second component redefined as 30. Struct components can be redefined likewise. If the value of s is a store then the component under some key k can be changed to 10 by s{#k} = 10 Similarly, if the value of the variable l is a list and the value of the variable i is an integer marking an existing position in the list then, for instance, l[i] = l[i-1] redefines the value of the element in the list at position i , where i is the value of i , to be the same as the previous element. However, if l is a vector rather than a list then this assignment is illegal since vectors can be assigned as a whole only. If the values of v and w are vectors and v can be assigned to then one can assign to it in vectorized way using v =. w Type annotations The compiler tries to infer the types for each value automatically. However, sometimes there is not enough information and it may be necessary to declare the types of some subexpressions manually. This can be done with e : q where e is an expression and q is its qualified type. It is also allowed to declare the type partially, for example e :uint or e : uint @prover . A type annotation, if given, must always contain the data type, both qualifiers (stage and domain) are optional. Casts Providing a type annotation to an expression does not change the type of the expression. If the compiler discovers that the expression is actually not of the annotated type then a type error occurs. A cast expression can be used to change the type of an expression. In a cast expression, the as keyword is used to separate the expression and the type. For instance, if the value of e is an expression of whatever integer type then e as uint[3] is a cast expression whose value is the same value in the finite field of size 3. If the value of e is larger than 3 then remainder of it upon division by 3 is found. All integer types can be cast to each other; so can all boolean types. It is also possible to cast a boolean to an integer of the same modulus. However, casting integers to booleans is not allowed as a builtin operation since it would require deciding if an integer is zero or not and being able to continue computing (rather than halting on non-zero value like assert_zero ). This would involve non-trivial algorithms in the circuit computation model of ZK that we assume. Casts can be done on domains and stages as well. Such cast must respect the corresponding subtyping order. Hence it is always possible to cast from the public domain to the verifier and prover domains and from the verifier domain to the prover domain but not the other way round. A value at the post stage can be cast to the pre stage but not vice versa. If a domain cast is applied to a list or vector then a deep cast is performed. This term means that the cast is applied to all constituents of the list or vector that are in a domain lower than the new domain of the list or vector. For instance, suppose that x is of type list[list[uint $pre @prover] $pre @verifier] $pre @public , i.e., the value of x is a list of lists of integers in the prover's domain, whereby the intermediate list structures are in the verifier's domain and the outermost list structure is public. Then the type of the expression x as @prover will be list[list[uint $pre @prover] $pre @prover] $pre @prover which means that the intermediate list structures are also raised to the prover's domain. On the other hand, the type of the expression x as @verifier will be list[list[uint $pre @prover] $pre @verifier] $pre @verifier since the integers inside the innermost lists are in a higher domain already. It is not possible to change both qualifiers or the data type and a qualifier within one cast. For instance, x as $pre @prover is incorrect; instead, one must perform two casts by writing x as $pre as @prover . Statements and expressions with blocks To explain the remaining constructs for building expressions, the notions of statements and blocks must be introduced. Statements Statements form a syntactic category distinct from expressions but still close to expressions as most statements contain expressions and are themselves necessary for building larger expressions. Informally, statements could be described as syntactic constructs that have a side effect rather than a meaningful return value. All statements end in a semicolon. In particular, any expression of the unit type can be used as a statement. Other statements include the break and continue statements and new variable definitions. The break and continue statements can be used in the body of a loop and have roughly the same meaning as in C. That is, continue starts a new iteration of the loop body and break jumps out of the loop. New variable definitions are written in one of the following forms: let x : t = e ; let mut x : t = e ; let rec x : t = e ; Here x is the new variable, t is a type expression that denotes the type of x and e is an expression. The variable x is initialized to the value of the expression e . The modifier mut makes x mutable. Mutability in ZK-SecreC is a property of variable and propagates to all components of the value of the variable if the value is a data structure. The modifier rec allows the definition to be recursive, i.e., x to occur in e . This can be used only for defining a list by expressing its elements in terms of previous elements. A variable definition without modifiers does not allow recursive definition nor mutating the value of the new variable later. The type expression along with the preceding colon can be omitted if ZK-SecreC is able to infer the type of e . Often it is not the case. For instance, the return type of a vectorized application must usually be explicitly given like in let t3 = ...; let trash : arr[() $pre @public] = assert_zero.(t3); ... Blocks A block is a sequence of statements, possibly followed by an expression, in braces. If the content of a block ends with an expression then the value of the block equals the value of the expression. If the block does not end with an expression then the block returns the single value of the unit type. One can make this difference according to whether the last item in the block ends with a semicolon or not. All statements and the final expression, if any, are executed in order before the final value is returned. The sequence of statements in a block may be empty. An totally empty block {} is also allowed. The latter is the easiest way to denote the single value of the unit type. Lambda expressions Lambda expressions enable one to introduce new functions locally rather than at the top level. The simplest form of a lambda expression is fn ( x 1 , ... , x n ) b where x 1 ,..., x n are variables standing for formal parameters and b is a block that constitutes the body of the new function. The scope of the formal parameters extends over the block b . The lambda expression denotes the function that evaluates its body after assigning the values of actual parameters to the corresponding formal parameters. Arguments of functions defined by lambda expressions are passed by value (immutable). The formal parameters of a lambda expression can be annotated with their types but this is not mandatory. Likewise, one can annotate the return type just after the parameter sequence in the form -> t . Omitting the return type does not restrict the return type in any way. For instance, fn (x) { x*x+1 } denotes the function that returns the number one larger than the square of the argument. The same function can be written also as fn (x : uint) -> uint { x*x+1 } . This restricts the unqualified type to be uint while leaves the stage and domain unspecified. Note that a lambda expression cannot be polymorphic, implying that a function defined by a lambda expression cannot have different types of arguments in different applications. A function defined by lambda expression can be declared a sieve function by adding the keyword sieve at the beginning of the expression. This forces the function to be compiled to a function gate in Circuit-IR and applications of the function to be compiled to calls of that function gate. Applications of functions not declared as sieve functions are inlined. Declaring a user-defined function as a sieve function is required if the function has vectorized applications. Conditional expressions A standard conditional expression is of the form if ( e ) b 1 else b 2 where e is an expression whereas b 1 and b 2 are blocks. When evaluating this expression, the expression e is evaluated first. Depending on the value of e , either b 1 or b 2 is evaluated and the value of that block becomes the value of the conditional expression. One can also use a type constraint c instead of condition e . Then b 1 or b 2 is evaluated, depending on if the type constraint holds or not. For instance, it is possible to use the following syntax in a control flow to change the function behaviour based on the actual value of a domain parameter @D : if (@D <= @verifier) { ... // Operations if the domain is `@public` or `@verifier` } else { ... // Operations if the domain is `@prover` } Similarly, it is possible to do different things depending on the actual value of a stage parameter: if (post $S) { ... // Operations if the stage is $post } else { ... // Operations if the stage is $pre } The else branch can be omitted. In this case, an else branch else {} is internally added by the compiler. The program is not type correct if the conditional expression fails to type after this addition. For loops For loops are written as for x in e 1 .. e 2 b , where x is a fresh variable, e 1 and e 2 are expressions and b is a block. The expressions must evaluate to integer bounds. The scope of the variable x embraces the block b but not the expressions e 1 and e 2 . The block b is executed for all values of the variable x within the range determined by the bounds, in the increasing order of these values. The lower bound is included in the range while the upper bound is excluded from it. Hence the number of iterations equals the difference of the upper and lower bounds. The value of the for loop is the list of all values returned by the body of the loop during all iterations, in the order of evaluation. If the value of e 2 is smaller than the value of e 1 then the body of the loop is executed no times. Note that the bounds are interpreted as 64-bit unsigned integers. Therefore, if e 2 is, e.g., -1 then the loop runs until the loop index becomes 2 64 -1. When defining a list with a for loop, the body of the loop is allowed to refer to the elements with a smaller index in the list. Referring to the same list is possible only if the for loop is the right-hand side of a definition of a new variable and the definition starts with let rec . For instance, the following piece of code is a legal content of a block and computes the sum of integers 1, 2, 3: let xs : list[uint $pre @public] = [1, 2, 3]; let rec sums_xs : list[uint $pre @public] = for i in 0..length(xs) { if (i == 0) { xs[i] } else { sums_xs[i-1] + xs[i] } }; sums_xs[length(xs) - 1] Zip expressions There is also a construct in ZK-SecreC that enables one to build new vectors from existing ones by doing the same operations on the corresponding elements. The construct is of the form zip x 1 in e 1 , ... , x n in e n with b where x 1 ,..., x n are fresh variables, e 1 ,..., e n are expressions and b is a block. The expressions must evaluate to vectors. For each evaluation of the body, the variables are assigned corresponding elements of the vectors and the value of the body b will be the corresponding element of the result vector. Note that the scope of all local variables x 1 ,..., x n equals the block b regardless of their position before the keyword with , i.e., variables introduced by the zip expression cannot be used in any of expressions e 1 ,..., e n (even in those that follow the location where the variable is bound). This restriction is necessary for allowing the result to be computed by vectorized function application. Technically, this construct creates a local sieve function with the iterator variables as parameters and the body of the zip construct as the body, and applies it in vectorized way to the given vectors. Hence all the vectors in the zip construct must have the same length and the result is again a vector of the same length. For instance, let zs = zip x in xs, y in ys with { x * y + 1 }; is equivalent to let f = sieve fn (x, y) { x * y + 1 }; let zs = f.(xs, ys); Wire expression With a type cast, one can convert a value at the post stage to the pre stage but not vice versa. To specify circuit inputs, values at the pre stage must be converted to the post stage. This is done using wire expressions of the form wire b where b is a block whose value is to be converted. Wire expressions can be used to cast an integer or a boolean value from the pre stage to the post stage. In either case, the modulus must be finite. As a wire expression brings values from the unreliable world to the circuit which should be kept reliable, it is potentially a dangerous operation, especially if the value belongs to the prover's domain. Bringing a value in the prover's domain from the pre stage to the post stage means that the prover is asked to input the value to the circuit, but a malicious prover can provide incorrect values. Hence, whenever a value in the prover's domain is put on a wire using a wire expression, the programmer should provide subsequent correctness checks of the value. In particular, when bringing public or the verifier's values to the stage $post and casting them to the domain @prover , it is important to pay attention to the order in which the conversions are performed. In the following example, we cannot be sure whether the resulting value is taken from the iterator or chosen arbitrarily by the prover: for i in 0..100 { let j = wire { i as uint[N] as @prover }; /* j is used in some place which expects a value in domain @prover */ } Here the value of i was cast to the domain @prover before it was brought into $post . This means that the prover has total control over the value stored in the circuit. The correct way is to first bring the value of i to the stage $post and then cast to the domain @prover : for i in 0..100 { let j = (wire { i as uint[N] }) as @prover; /* same as before */ } (In both cases, we assume that N has been defined as a supported field size.) Match expressions ZK-SecreC supports match expressions that serve the purpose of performing oblivious choices depending on values on wires. Match expressions are of the form match e { p 1 => b 1 , ......, p n => b n }, where e is an expression, p 1 ,..., p n are patterns and b 1 ,..., b n are blocks. A pattern is an integer literal or a variable or an underscore. The expression e is evaluated first and the result should be a value on wire. After that, the first block b i such that the value of e matches the corresponding pattern p i is evaluated. A value matches a literal pattern if it equals the value of the literal; a variable and an underscore are matched by any value. If a pattern is a variable then that variable can be used in the corresponding block and its value equals the value of e . Unlike variables, the underscore cannot be used in the right-hand side for referring to the value. In a standard arithmetic circuit, an oblivious choice that evaluates only the right branch is impossible. A choice function implemented in a standard arithmetic circuit would evaluate all branches and combine the results obliviously. Compiling of match expressions according to the intended semantics relies on the disjunction plugin of Circuit-IR that implements a corresponding extension of arithmetic circuit.","title":"Expressions"},{"location":"3-reference/3-expressions/#expressions","text":"","title":"Expressions"},{"location":"3-reference/3-expressions/#primitive-expressions","text":"This subsection describes expressions that are primitive w.r.t. the Dijkstra shunting yard algorithm. This means that the structure within them does not affect parsing of parts of the expression outside of them. These parts may nevertheless have their own inner structure.","title":"Primitive expressions"},{"location":"3-reference/3-expressions/#literals","text":"Integer literals can stand for values of any type uint[ N ] and also values of type uint , regardless of the stage and domain. If the number expressed by the literal equals or exceeds the modulus then the value of the literal equals the reminder of this number upon division by the modulus. Similarly, Boolean literals can stand for values of any type bool[ N ] and also values of type bool , regardless of the stage and domain. String literals can be in any of the three domains but the stage can be $pre only.","title":"Literals"},{"location":"3-reference/3-expressions/#tuples-structs-stores","text":"The tuple of expressions e 1 , ..., e n , in this order, is written as ( e 1 , ... , e n ) . The value of the latter expression is the tuple of values of the component expressions, in the given order. New structs can be created by the expression S { x 1 : e 1 , ... , x 1 : e n } , where S is the name of the struct type, x 1 ,..., x n are names of fields in structs of this type, and e 1 ,..., e n are expressions. Every field that the struct type requires must occur in the expression. The value of this expression is the struct containing precisely all the named fields, the value of each field being the value of the subexpression corresponding to the name of the field. Since the time stores were first introduced into ZK-SecreC as a builtin feature, stores can be written using the delimiters {# ... } . Non-empty stores are written by providing some initial key-value pairs in the form {# k 1 => v 1 , ... , k n => v n } whereas empty stores are written as {#} . Here, both k i and v i may be any expressions. Although stores in the post stage are no more builtin, the old builtin store syntax is still usable for creating them. Stores in the pre stage can be created similarly using the delimiters {## ... } .","title":"Tuples, structs, stores"},{"location":"3-reference/3-expressions/#lists","text":"Lists with a known constant length can be created by expressions of the form [ e 1 , ... , e n ] . The value of this expression is the list whose elements are the values of expressions e 1 ,..., e n in this order. An empty list is written as [] . To create a new list whose all elements are equal, one can write an expression [ e ; n ] where e is an expression whose value is the repeating element and n is an expression whose value equals the number of repetitions.","title":"Lists"},{"location":"3-reference/3-expressions/#parenthesized-expressions","text":"Expressions in the form ( e ) where e is any expression evaluate to the same value as e .","title":"Parenthesized expressions"},{"location":"3-reference/3-expressions/#compound-expressions","text":"This subsection surveys expressions composed from smaller expressions using function and operator applications and other similar constructs.","title":"Compound expressions"},{"location":"3-reference/3-expressions/#operator-application","text":"Expressions can be composed using unary and binary operators. In the case of builtin operators, predefined precedences are used to determine the right syntax tree of expressions. If another syntax tree is desired, subexpressions have to be parenthesized. For example, 1 + 2 * 3 is evaluated to 7 as multiplication binds tighter than addition, whereas (1 + 2) * 3 evaluates to 9 because now addition in parentheses is done before multiplication. If more than two subexpressions are connected by binary operators of the same precedence then the leftmost one takes precedence. Equality and comparisons are exceptions as applying them in sequence without specifying the order by parentheses is a syntax error. Currently, precedences do not work with user-defined operators. Hence one must show the order of operations with parentheses, except when only builtin operators are involved.","title":"Operator application"},{"location":"3-reference/3-expressions/#function-applications","text":"Monomorphic function applications are written as expressions of the form f ( a 1 , ... , a n ) , where f is the name of the function and a 1 , ..., a n are the argument expressions. In a larger expression, function applications bind tighter than any unary or binary operator. Polymorphic functions usually can be called in the same way without specifying the actual type arguments, but if the actual type arguments cannot be inferred then they have to be specified before the ordinary argument sequence as a comma-separated list in brackets. The function identifier and the opening bracket must be separated by double colon. For instance, if the function sum assumes a stage and a domain as type level parameters like in the examples Getting Started and this function is called with an actual (data level) parameter xs that fixes the stage and domain to be $post and @verifier , respectively, then the programmer can make the type level arguments explicit by writing the call as sum::[$post,@verifier](xs) . Function arguments can be passed by value or by reference; the particular way is fixed for every function and its argument. An argument that is passed by value is written as just an expression whose value is to be passed to the function. A pass-by-reference argument must be preceded by keyword ref and it must be a mutable variable or a (direct or indirect) lookup into a mutable data structure. The function may change the value of such arguments in general. Pass-by-value parameters are immutable. Behind the scene, pass-by-value parameters may actually be passed by reference. Immutability guarantees that this does not change the semantics. So one may pass by value large data structures without the risk of wasting time and space for copying the data structure. The only difference between pass-by-value and pass-by-reference is the ability to mutate the parameter in the latter case. Functions that do not have pass-by-reference parameters are allowed to be applied partially. This means that one can provide less arguments than the function is able to take. The value of such expression is a function that can take the remaining arguments. A function with at least one pass-by-reference parameter cannot be applied partially.","title":"Function applications"},{"location":"3-reference/3-expressions/#vectorized-applications","text":"ZK-SecreC allows the programmer to syntactically lift functions and operators to vectors. Vectorized application is identified by a period. For example, applying function f to arguments a 1 , ..., a n in vectorized way is denoted by f .( a 1 , ... , a n ) , i.e., using .( as the delimiter opening the sequence of arguments. The value of this expression is well defined only if the values of all argument expressions are vectors of identical length. Evaluation of the vectorized application produces a new vector of the same length by applying function f pointwise. To apply an operator in vectorized way, dot is written after the operator without space, e.g., the value of the expression x *. y is the pointwise product of the values of expressions x and y (provided that they are vectors of identical length). In addition to 1-dimensional vectors, vectorized applications can also be used with higher-dimensional tensors. In this case, a 1 ,..., a n must be tensors with the same shape and the result of the application also has this shape. If the iter plugin of Circuit-IR is supported by CCC then the compiler translates vectorized applications via the iter plugin operations. If the iter plugin is not supported, vectorized applications are compiled via unrolling.","title":"Vectorized applications"},{"location":"3-reference/3-expressions/#assertions","text":"The assert builtin function is used to declare a new output node of the circuit. The assertion succeeds if the value of its argument is true. Similarly, assert_zero builtin function declares a new output node of the circuit. It succeeds if the value of its argument is zero. Both these functions must take its argument at the post stage. Besides these assertion functions, ZK-SecreC provides assertion functions dbg_assert and dbg_assert_eq without circuit output for debugging. The former assert succeeds if the value of its argument is true. The latter one assumes two arguments of integer types with possibly different modules and succeeds if the integer values (i.e., remainders upon division by the corresponding modules) are equal. These functions assume that their arguments are in the pre stage. These functions do not contribute to the circuit, but the program halts with an error message whenever any of these assertions fail.","title":"Assertions"},{"location":"3-reference/3-expressions/#builtin-operators-and-functions","text":"The following builtin operators are available: Operators Arity Precedence Associativity Meaning ! 1 90 negation * / % 2 80 left product, quotient, remainder + - 2 70 left sum, difference <= >= < > 2 50 none comparisons == 2 40 none equality & 2 30 left conjunction ^ 2 20 left xor | 2 10 left disjunction The higher the precedence, the more tightly the operator binds its arguments. The builtin functions are described in the Builtins subsection of this documentation.","title":"Builtin operators and functions"},{"location":"3-reference/3-expressions/#lookups-and-slices","text":"Components of tuples, structs and stores, as well as elements of lists and vectors, can be accessed using the corresponding lookup syntax. A tuple component can be accessed by index. The value of an expression of the form e . i , where e is an expression and i is an integer literal, is the i -th component of the tuple that e evaluates to. As the index must be a literal rather than an arbitrary expression, the compiler can decide if the index falls into the bounds required by the type of the tuple and give a static error otherwise. Indexing starts from zero. A struct component can be accessed with a similar syntax but using a field name instead of an index. The value of an expression of the form e . x , where e is an expression and x is a field name, is the component associated to the name x in the struct that e evaluates to. Again, the compiler can decide if the access is correct as available field names are determined by the struct type. Store elements can be accessed by expressions of the form e {# k } . Here, e and k are expressions whose values are the store and a key, respectively. An element in a list or vector can be accessed using its index in square brackets, i.e., with an expression of the form e [ i ] where e and i are expressions. Provided that the value of e is a list or vector and the value of i is a non-negative integer falling into the bounds of the list or vector, the value of the lookup expression is the corresponding element of the data structure. The compiler does not make sure that the index indeed falls between the bounds. If not, the computation halts abnormally. This is considered equivalent to ZK proof failure. ZK-SecreC allows using the square bracket syntax for extracting slices. To this end, one must specify a range of indices rather than a single index within brackets. The range is specified in terms of its lower bound and upper bound; the range contains all indices not less than the lower bound and less than the upper bound. The bounds of the range can be specified by any expressions and these expressions are separated by the double dot token. For example, e [ a .. b ] , where e , a and b are expressions, is a slice expression. Provided that the value of e is a list or vector and the values of both a and b are integers within the index bounds of the list or vector, the value of the slice expression is a new data structure of the same type as the original one (list or vector) and its elements are precisely the elements of the original data structure whose index falls into the range determined by the two integers (the first one being the lower bound). ZK-SecreC allows one to omit either of the two bounds. In this case, the corresponding bound is that of the original data structure. If both bounds are omitted, the result is a copy of the original data structure. A higher-dimensional tensor can also be sliced but only according to the first dimension as slicing by any other dimension would leave the elements on non-consecutive wires, which is not supported by Circuit-IR. Slicing an n -dimensional tensor uses the same syntax as vector slicing and returns another n -dimensional tensor.","title":"Lookups and slices"},{"location":"3-reference/3-expressions/#assignments","text":"Assignment is denoted by = in ZK-SecreC. For instance, ix = ix + 1 increases the value of the variable ix by one. For a variable to be assigned to, it must be a mutable local variable or a pass-by-reference parameter of function. If a variable can be assigned to, and its value is whatever data structure except a vector, then its components, components of components etc., can be assigned to one by one if necessary. Such assignment uses the same notation as lookup. For instance, t.1 = 30 is syntactically correct, provided that t can be assigned to. For type correctness, the type of variable t must be a tuple type with at least 2 components, the second of which is an integer type. As the result, the value of t will be the same tuple as before with the second component redefined as 30. Struct components can be redefined likewise. If the value of s is a store then the component under some key k can be changed to 10 by s{#k} = 10 Similarly, if the value of the variable l is a list and the value of the variable i is an integer marking an existing position in the list then, for instance, l[i] = l[i-1] redefines the value of the element in the list at position i , where i is the value of i , to be the same as the previous element. However, if l is a vector rather than a list then this assignment is illegal since vectors can be assigned as a whole only. If the values of v and w are vectors and v can be assigned to then one can assign to it in vectorized way using v =. w","title":"Assignments"},{"location":"3-reference/3-expressions/#type-annotations","text":"The compiler tries to infer the types for each value automatically. However, sometimes there is not enough information and it may be necessary to declare the types of some subexpressions manually. This can be done with e : q where e is an expression and q is its qualified type. It is also allowed to declare the type partially, for example e :uint or e : uint @prover . A type annotation, if given, must always contain the data type, both qualifiers (stage and domain) are optional.","title":"Type annotations"},{"location":"3-reference/3-expressions/#casts","text":"Providing a type annotation to an expression does not change the type of the expression. If the compiler discovers that the expression is actually not of the annotated type then a type error occurs. A cast expression can be used to change the type of an expression. In a cast expression, the as keyword is used to separate the expression and the type. For instance, if the value of e is an expression of whatever integer type then e as uint[3] is a cast expression whose value is the same value in the finite field of size 3. If the value of e is larger than 3 then remainder of it upon division by 3 is found. All integer types can be cast to each other; so can all boolean types. It is also possible to cast a boolean to an integer of the same modulus. However, casting integers to booleans is not allowed as a builtin operation since it would require deciding if an integer is zero or not and being able to continue computing (rather than halting on non-zero value like assert_zero ). This would involve non-trivial algorithms in the circuit computation model of ZK that we assume. Casts can be done on domains and stages as well. Such cast must respect the corresponding subtyping order. Hence it is always possible to cast from the public domain to the verifier and prover domains and from the verifier domain to the prover domain but not the other way round. A value at the post stage can be cast to the pre stage but not vice versa. If a domain cast is applied to a list or vector then a deep cast is performed. This term means that the cast is applied to all constituents of the list or vector that are in a domain lower than the new domain of the list or vector. For instance, suppose that x is of type list[list[uint $pre @prover] $pre @verifier] $pre @public , i.e., the value of x is a list of lists of integers in the prover's domain, whereby the intermediate list structures are in the verifier's domain and the outermost list structure is public. Then the type of the expression x as @prover will be list[list[uint $pre @prover] $pre @prover] $pre @prover which means that the intermediate list structures are also raised to the prover's domain. On the other hand, the type of the expression x as @verifier will be list[list[uint $pre @prover] $pre @verifier] $pre @verifier since the integers inside the innermost lists are in a higher domain already. It is not possible to change both qualifiers or the data type and a qualifier within one cast. For instance, x as $pre @prover is incorrect; instead, one must perform two casts by writing x as $pre as @prover .","title":"Casts"},{"location":"3-reference/3-expressions/#statements-and-expressions-with-blocks","text":"To explain the remaining constructs for building expressions, the notions of statements and blocks must be introduced.","title":"Statements and expressions with blocks"},{"location":"3-reference/3-expressions/#statements","text":"Statements form a syntactic category distinct from expressions but still close to expressions as most statements contain expressions and are themselves necessary for building larger expressions. Informally, statements could be described as syntactic constructs that have a side effect rather than a meaningful return value. All statements end in a semicolon. In particular, any expression of the unit type can be used as a statement. Other statements include the break and continue statements and new variable definitions. The break and continue statements can be used in the body of a loop and have roughly the same meaning as in C. That is, continue starts a new iteration of the loop body and break jumps out of the loop. New variable definitions are written in one of the following forms: let x : t = e ; let mut x : t = e ; let rec x : t = e ; Here x is the new variable, t is a type expression that denotes the type of x and e is an expression. The variable x is initialized to the value of the expression e . The modifier mut makes x mutable. Mutability in ZK-SecreC is a property of variable and propagates to all components of the value of the variable if the value is a data structure. The modifier rec allows the definition to be recursive, i.e., x to occur in e . This can be used only for defining a list by expressing its elements in terms of previous elements. A variable definition without modifiers does not allow recursive definition nor mutating the value of the new variable later. The type expression along with the preceding colon can be omitted if ZK-SecreC is able to infer the type of e . Often it is not the case. For instance, the return type of a vectorized application must usually be explicitly given like in let t3 = ...; let trash : arr[() $pre @public] = assert_zero.(t3); ...","title":"Statements"},{"location":"3-reference/3-expressions/#blocks","text":"A block is a sequence of statements, possibly followed by an expression, in braces. If the content of a block ends with an expression then the value of the block equals the value of the expression. If the block does not end with an expression then the block returns the single value of the unit type. One can make this difference according to whether the last item in the block ends with a semicolon or not. All statements and the final expression, if any, are executed in order before the final value is returned. The sequence of statements in a block may be empty. An totally empty block {} is also allowed. The latter is the easiest way to denote the single value of the unit type.","title":"Blocks"},{"location":"3-reference/3-expressions/#lambda-expressions","text":"Lambda expressions enable one to introduce new functions locally rather than at the top level. The simplest form of a lambda expression is fn ( x 1 , ... , x n ) b where x 1 ,..., x n are variables standing for formal parameters and b is a block that constitutes the body of the new function. The scope of the formal parameters extends over the block b . The lambda expression denotes the function that evaluates its body after assigning the values of actual parameters to the corresponding formal parameters. Arguments of functions defined by lambda expressions are passed by value (immutable). The formal parameters of a lambda expression can be annotated with their types but this is not mandatory. Likewise, one can annotate the return type just after the parameter sequence in the form -> t . Omitting the return type does not restrict the return type in any way. For instance, fn (x) { x*x+1 } denotes the function that returns the number one larger than the square of the argument. The same function can be written also as fn (x : uint) -> uint { x*x+1 } . This restricts the unqualified type to be uint while leaves the stage and domain unspecified. Note that a lambda expression cannot be polymorphic, implying that a function defined by a lambda expression cannot have different types of arguments in different applications. A function defined by lambda expression can be declared a sieve function by adding the keyword sieve at the beginning of the expression. This forces the function to be compiled to a function gate in Circuit-IR and applications of the function to be compiled to calls of that function gate. Applications of functions not declared as sieve functions are inlined. Declaring a user-defined function as a sieve function is required if the function has vectorized applications.","title":"Lambda expressions"},{"location":"3-reference/3-expressions/#conditional-expressions","text":"A standard conditional expression is of the form if ( e ) b 1 else b 2 where e is an expression whereas b 1 and b 2 are blocks. When evaluating this expression, the expression e is evaluated first. Depending on the value of e , either b 1 or b 2 is evaluated and the value of that block becomes the value of the conditional expression. One can also use a type constraint c instead of condition e . Then b 1 or b 2 is evaluated, depending on if the type constraint holds or not. For instance, it is possible to use the following syntax in a control flow to change the function behaviour based on the actual value of a domain parameter @D : if (@D <= @verifier) { ... // Operations if the domain is `@public` or `@verifier` } else { ... // Operations if the domain is `@prover` } Similarly, it is possible to do different things depending on the actual value of a stage parameter: if (post $S) { ... // Operations if the stage is $post } else { ... // Operations if the stage is $pre } The else branch can be omitted. In this case, an else branch else {} is internally added by the compiler. The program is not type correct if the conditional expression fails to type after this addition.","title":"Conditional expressions"},{"location":"3-reference/3-expressions/#for-loops","text":"For loops are written as for x in e 1 .. e 2 b , where x is a fresh variable, e 1 and e 2 are expressions and b is a block. The expressions must evaluate to integer bounds. The scope of the variable x embraces the block b but not the expressions e 1 and e 2 . The block b is executed for all values of the variable x within the range determined by the bounds, in the increasing order of these values. The lower bound is included in the range while the upper bound is excluded from it. Hence the number of iterations equals the difference of the upper and lower bounds. The value of the for loop is the list of all values returned by the body of the loop during all iterations, in the order of evaluation. If the value of e 2 is smaller than the value of e 1 then the body of the loop is executed no times. Note that the bounds are interpreted as 64-bit unsigned integers. Therefore, if e 2 is, e.g., -1 then the loop runs until the loop index becomes 2 64 -1. When defining a list with a for loop, the body of the loop is allowed to refer to the elements with a smaller index in the list. Referring to the same list is possible only if the for loop is the right-hand side of a definition of a new variable and the definition starts with let rec . For instance, the following piece of code is a legal content of a block and computes the sum of integers 1, 2, 3: let xs : list[uint $pre @public] = [1, 2, 3]; let rec sums_xs : list[uint $pre @public] = for i in 0..length(xs) { if (i == 0) { xs[i] } else { sums_xs[i-1] + xs[i] } }; sums_xs[length(xs) - 1]","title":"For loops"},{"location":"3-reference/3-expressions/#zip-expressions","text":"There is also a construct in ZK-SecreC that enables one to build new vectors from existing ones by doing the same operations on the corresponding elements. The construct is of the form zip x 1 in e 1 , ... , x n in e n with b where x 1 ,..., x n are fresh variables, e 1 ,..., e n are expressions and b is a block. The expressions must evaluate to vectors. For each evaluation of the body, the variables are assigned corresponding elements of the vectors and the value of the body b will be the corresponding element of the result vector. Note that the scope of all local variables x 1 ,..., x n equals the block b regardless of their position before the keyword with , i.e., variables introduced by the zip expression cannot be used in any of expressions e 1 ,..., e n (even in those that follow the location where the variable is bound). This restriction is necessary for allowing the result to be computed by vectorized function application. Technically, this construct creates a local sieve function with the iterator variables as parameters and the body of the zip construct as the body, and applies it in vectorized way to the given vectors. Hence all the vectors in the zip construct must have the same length and the result is again a vector of the same length. For instance, let zs = zip x in xs, y in ys with { x * y + 1 }; is equivalent to let f = sieve fn (x, y) { x * y + 1 }; let zs = f.(xs, ys);","title":"Zip expressions"},{"location":"3-reference/3-expressions/#wire-expression","text":"With a type cast, one can convert a value at the post stage to the pre stage but not vice versa. To specify circuit inputs, values at the pre stage must be converted to the post stage. This is done using wire expressions of the form wire b where b is a block whose value is to be converted. Wire expressions can be used to cast an integer or a boolean value from the pre stage to the post stage. In either case, the modulus must be finite. As a wire expression brings values from the unreliable world to the circuit which should be kept reliable, it is potentially a dangerous operation, especially if the value belongs to the prover's domain. Bringing a value in the prover's domain from the pre stage to the post stage means that the prover is asked to input the value to the circuit, but a malicious prover can provide incorrect values. Hence, whenever a value in the prover's domain is put on a wire using a wire expression, the programmer should provide subsequent correctness checks of the value. In particular, when bringing public or the verifier's values to the stage $post and casting them to the domain @prover , it is important to pay attention to the order in which the conversions are performed. In the following example, we cannot be sure whether the resulting value is taken from the iterator or chosen arbitrarily by the prover: for i in 0..100 { let j = wire { i as uint[N] as @prover }; /* j is used in some place which expects a value in domain @prover */ } Here the value of i was cast to the domain @prover before it was brought into $post . This means that the prover has total control over the value stored in the circuit. The correct way is to first bring the value of i to the stage $post and then cast to the domain @prover : for i in 0..100 { let j = (wire { i as uint[N] }) as @prover; /* same as before */ } (In both cases, we assume that N has been defined as a supported field size.)","title":"Wire expression"},{"location":"3-reference/3-expressions/#match-expressions","text":"ZK-SecreC supports match expressions that serve the purpose of performing oblivious choices depending on values on wires. Match expressions are of the form match e { p 1 => b 1 , ......, p n => b n }, where e is an expression, p 1 ,..., p n are patterns and b 1 ,..., b n are blocks. A pattern is an integer literal or a variable or an underscore. The expression e is evaluated first and the result should be a value on wire. After that, the first block b i such that the value of e matches the corresponding pattern p i is evaluated. A value matches a literal pattern if it equals the value of the literal; a variable and an underscore are matched by any value. If a pattern is a variable then that variable can be used in the corresponding block and its value equals the value of e . Unlike variables, the underscore cannot be used in the right-hand side for referring to the value. In a standard arithmetic circuit, an oblivious choice that evaluates only the right branch is impossible. A choice function implemented in a standard arithmetic circuit would evaluate all branches and combine the results obliviously. Compiling of match expressions according to the intended semantics relies on the disjunction plugin of Circuit-IR that implements a corresponding extension of arithmetic circuit.","title":"Match expressions"},{"location":"3-reference/4-top-level/","text":"Top-Level Declarations A ZK-SecreC program is a collection of top-level declarations. The order of the declarations is not important. The declarations can be spread over many files sometimes called modules after modules of code in other programming languages. But please be aware that this term has a potential to be confused with modulus. Imports An import brings names exported by another ZK-SecreC module in scope. Otherwise, names defined in a file are visible only throughout the file. For instance, the declaration use Std::*; imports all names exported by the ZK-SecreC module with name Std . To be found, the module must be in file with name Std.zksc either in the same directory as the calling module or in the standard library of ZK-SecreC. Despite the syntax, there is currently no way to import names one-by-one. Names defined at the top level must be unique throughout all the program, including the imported names. Type definitions One can define type synonyms at the top level. The kind of the defined type must be given explicitly. For instance, the declaration type N : Nat = 0x1fffffffffffffff; defines N as a new type synonym that refers to the type-level natural number expressed by the literal 0x1fffffffffffffff (the value of this hexadecimal literal is the Mersenne prime 2 61 -1). Type synonyms can take type arguments, in which case they are in principle functions on types. In a type definition, type parameters are introduced by a comma-separated list in brackets. Any formal type parameter must normally be equipped with its kind using the notation p : k where p is the parameter (a type variable) and k is its kind. However, parameter kinds Stage and Domain can be settled by $ and @ , respectively, preceding the parameter name, in which case the kind name is not written. If the definition starts with the keyword pub then the defined name is exported by the module. Otherwise, the defined name is visible within the current file only, regardless of the imports occurring in other files. For instance, the library file Std.zksc contains the following definitions that introduce type synonyms for types of integers of 8, 16, 32, 64 and 128 bits: pub type u8 : Unqualified = uint[0x100]; pub type u16 : Unqualified = uint[0x10000]; pub type u32 : Unqualified = uint[0x100000000]; pub type u64 : Unqualified = uint[0x10000000000000000]; pub type u128 : Unqualified = uint[0x100000000000000000000000000000000]; Struct declarations New struct types can also be defined at the top level. A struct declaration introduces the name of the struct type and lists the names of all fields of the structs in this type along with the field types. Type parameters are allowed here, too. For instance, dates are introduced in the standard library with the following struct declaration: pub struct Date[$S, @D, N : Nat] { year : uint[N] $S @D, month : uint[N] $S @D, day : uint[N] $S @D, code : uint[N] $S @D } This declaration introduces a new type with name Date which is parametrized in a stage $S , a domain @D and a type level natural number N . Each element in this type is a data structure containing four fields with names year , month , day and code . All the fields must have the same type uint[N] $S @D , where N , $S and @D are the real types associated to the type parameters. The keyword pub indicates that the name of the type and the names of the fields are exported. Function definitions Like most programming languages, ZK-SecreC allows programmers to define functions. Native functions The usual native function definitions have the following syntax: Function = 'pub'? 'sieve'? 'fn' Identifier TypeParams? '(' Params ')' RetType? Constraints? Body RetType = '->' Type Constraints = 'where' TypePreds The modifier pub indicates that the function is exported from the file. Like in the case of functions defined locally, the modifier sieve instructs the function to be compiled as a function gate in Circuit-IR. Without the modifier, no corresponding function in Circuit-IR is created, all calls of this function are inlined, and vectorized applications of the function are impossible. Like type parameters of type synonyms, type parameters of functions are written as a comma separated list in brackets. They introduce polymorphism, i.e., the function can be called with different types (without having to indicate the actual type arguments). The kinds of all type parameters must be explicit. In the case of stage and domain parameters, kind is reflected by the initial character ( $ or @ , respectively). In other cases, kind must be indicated after colon like in N : Nat . A sieve function is not allowed to be stage polymorphic. Ordinary parameters are written as a comma separated list in parentheses. The parameters must be given together with their types. These types can depend on the type parameters introduced earlier. Vectorized application of user defined functions is allowed only if they have been declared as sieve functions, still sieve functions can also be applied in non-vectorized way like usual functions. Parameters of sieve functions that are called in vectorized way must have sized types in order to be put into vectors, and such sieve functions must have at least one parameter. If a sieve function is only called in non-vectorized way then arguments and result values can also be lists whose length is in the public domain. Such function is allowed to have no parameters. The result of applying a sieve function partially non-vectorized is considered a new sieve function: sieve fn f(x : uint[N] $pre @public, y : uint[N] $post @prover) where Field[N] { ... } fn main() where Field[N], Vectorization { let x : uint[N] $pre @public = ...; let ys : arr[uint[N] $post @prover] = ...; let g = f(x); let trash : arr[() $pre @public] = g.(ys); } Note the difference between the sieve modifier and the Vectorization constraint: The former is necessary for the function to be called in vectorized way, whereas the latter is required for the function to be able to call other functions in vectorized way. A function parameter can be preceded by the keyword ref , in which case it is a pass-by-reference parameter, i.e., mutable in the body of the function. Parameters without the keyword ref are immutable. A function with no return type given is assumed to have the return type () . A function may have constraints imposed on its type. If any, constraints are written as a comma-separated list of type predicates after the keyword where . Each type predicate is a condition imposed on types. Standard examples are @D <= @verifier and Field[N] . The former requires the domain-kinded type variable @D to be @verifier at highest, i.e., either @public or @verifier . The latter requires N to be a modulus allowed by the associated CCC file as a field. Note that type predicates do not have to mention type parameters of the function. For instance, N in the last example may be defined as an integer constant outside the function, and even can be replaced with an integer literal in the predicate. Constraints such as ObliviousChoice and Vectorization do not have a parameter at all. Such predicates are reasonable as their truth value can depend on a CCC file which is not part of the ZK-SecreC program. The body of a function must be a block. Throughout the program (including imported modules), there must be exactly one function with name main . The program starts execution from the body of this function. The type of the main function must not contain free type variables, except those of kind Nat . Foreign functions One can call Rust functions in ZK-SecreC. To this end, the Rust function must be given a corresponding signature in ZK-SecreC. The signature of a foreign function has the same shape as that of a native function, but the keyword extern must occur immediately before the keyword fn . The body must be omitted, e.g., extern fn sqr[@D](x : u64 $pre @D) -> u64 $pre @D; A foreign function cannot be declared as sieve . The Rust functions must be implemented in a Rust file. The -e parameter of runrust specifies the Rust file that implements the foreign functions declared in the ZK-SecreC file. Any Rust compiler errors from that Rust file will reference src/Rust/zksc-app-lib/src/externs.rs , which is where the Rust file is copied to, but the line numbers in the error messages are correct. The following table shows the correspondence between ZK-SecreC and Rust types; here T' denotes the Rust type corresponding to the ZK-SecreC type T : ZK-SecreC Rust () $pre @D () bool $pre @D bool bool[N] $pre @D bool u8 $pre @D u8 u16 $pre @D u16 u32 $pre @D u32 u64 $pre @D u64 u128 $pre @D u128 uint $pre @D BigInt uint[N] $pre @D Value if N is finite and other than 2 n with n =8,16,32,64,128 string $pre @D String T : Qualified Value list[() $pre @D] Value arr[() $pre @D] Value list[T] or arr[T] Vec<T'> if T' is bool , u8 , u16 , u32 , u64 , u128 list[T] or arr[T] Vec<Value> if T' is not () , bool , u8 , u16 , u32 , u64 , u128 tuple[T1,T2] (T1',T2') if not a pass-by-reference argument tuple[T1,T2,T3] (T1',T2',T3') if not a pass-by-reference argument tuple[T1,T2,T3,T4] (T1',T2',T3',T4') if not a pass-by-reference parameter tuple[T1,T2,T3,T4,T5] (T1',T2',T3',T4',T5') if not a pass-by-reference parameter tuple[T1,...,Tn] Box<[Value]> struct Box<[Value]> store[T1,T2] $S @D Value For non-primitive Rust types other than tuples, i.e. for Value , Vec , Box , BigInt , String , the Rust type must be prefixed by & when used for an argument of an foreign function (e.g. &Value instead of Value ) but not when used for a return value. The prefix is also used inside tuples (e.g. ( &Value , &BigInt )). Primitive Rust types and Rust tuples are not prefixed when used as non-ref parameters. For pass-by-reference parameters, the prefix is &mut . Rust tuples (e.g. ( &mut Value , &mut BigInt )) cannot be used for pass-by-reference parameters, instead &mut Box<[Value]> (or &mut Value ) must be used regardless of the number of components. Primitive Rust types are prefixed with &mut when used as pass-by-reference parameters. All the prefixed (borrowed) values can be cloned (using the method clone() in Rust) to get the non-prefixed (owned) value. This cloning is constant-time for Value (only increasing the reference count) but makes a copy of the whole data structure for Vec , Box , BigInt , and String . To avoid this copying, it is also possible to use Value ( &Value for pass-by-value parameters, &mut Value for pass-by-reference parameters) instead of these types when defining the Rust function. The Value , &Value , and &mut Value can be converted to/from the corresponding Rust types using the From and Into traits. The into() method is essential when implementing external functions on multidimensional lists/arrays or lists/arrays of tuples/BigInts/strings, as lists/arrays with non-primitive elements are always represented as Vec<Value> and the into() method needs to be used to convert the elements to/from the corresponding Rust types. It is also needed for tuples translated as Box<[Value]> . Slices cannot be passed to foreign functions. They can be removed (copying the elements of the slice to a new list/array) using the builtin function unslice (e.g., unslice(xs[1..]) instead of xs[1..] ). Implementing external Rust functions The module crate::externs_header , which re-exports some essential types, needs to be imported in every Rust file implementing functions used as ZK-SecreC foreign functions: use crate::externs_header::*; External function implementations must use the pub keyword, so that they can be used from the ZK-SecreC code. The first two parameters must be of types &ContextRef and &mut Stack , the variables can be _ as they are usually not needed. The next parameters are the type parameters (other than Unqualified ) of the ZK-SecreC function, the Rust type depends on the kind of the ZK-SecreC type parameter according to the following table: ZK-SecreC Rust domain ( @ ) DomainType stage ( $ ) StageType Nat &NatType Qualified QualifiedType Unqualified (no parameter) After that, there will be the ordinary parameters of the ZK-SecreC function. For the example foreign function sqr , we can have the following Rust implementation: pub fn sqr(_: &ContextRef, _: &mut Stack, _d: DomainType, x: u64) -> u64 { x * x } Here, we have _d: DomainType corresponding to the @D in ZK-SecreC and x: u64 corresponding to x : u64 $pre @D in ZK-SecreC. The variable names do not have to be the same as in ZK-SecreC. Effect declarations For guaranteeing preservation of privacy, static types are not enough. Besides types, the compiler of ZK-SecreC must keep track of effects . One can read more about effects in the Type system subsection. In brief, effects encode any medium (a word chosen to be maximally abstract) where an operation can cause observable changes (apart from the return value). Here, we need to know that there are stage effects and domain effects (besides others). In most cases, the compiler is able to infer effects, but sometimes (typically in the case of recursive functions) it fails to do it. The programmer can document effects of any functions in an effect declaration . If present, the effect declaration must be put directly before the function declaration. An effect declaration has the following syntax: EffectDecl = 'unchecked' 'eff' EffType '!' Effs Effs = Eff | Eff '+' Effs Eff = Stage | Domain Here, EffType is a sketch of the type of the function and Effs is a list of effects potentially arising during an execution of the function body. Only stage effects and domain effects can be given, with plus sign separating them. The type parameters of the function can be used in the effects. For instance, the auxiliary function sum in the subsection Getting Started of this documentation could have the following effect declaration: unchecked eff * -> * ! $S Lists and vectors can be indicated by brackets, so one could make the type sketch more precise by writing unchecked eff [*] -> * ! $S Similarly, a tuple type can be indicated by comma-separated sketches of the component types in brackets. Implementation declarations An implementation declaration introduces functions associated to a struct type. It is of the form impl s { ... } where s is a struct type name (that must be defined separately by a struct declaration) and the braces contain definitions of functions associated to the struct type. The function definitions in an implementation declaration have the same syntax and semantics as function definitions at the top level. The designers of implementation declarations initially had the aim of introducing object-oriented features into ZK-SecreC. Functions associated to struct types should have played the role of methods. Currently, these aims are not fully implemented. Functions defined in implementation declarations cannot be called explicitly. However, as a builtin feature, the function with name finalize , if present in the implementation declaration, is called on each struct of that type when it goes out of scope. The function finalize must take one parameter which has the corresponding struct type and its return type must be () $pre @public . This special feature firstly serves the aim of code modularization. A programmer can specify all boring checks concerning the struct in the finalizer where they do not disturb understanding the logic of the main functionality. Secondly, postponing all checks concerning a data item to the end of its lifetime sometimes enables the checks to be performed more efficiently because checking correctness of many operations together may allow optimizations compared to the checking of every operation separately. This is so in the case of store operations (reads and writes) and also in the case of inequalities of integers. This is the reason why comparison operations at the post stage implemented in the standard library require a supplementary data structure, a size asserter. The size asserter is a struct that collects information about numbers for which it must be checked that their binary representation uses at most a certain number of bits. Checking this for many integers together can be performed more efficiently than checking this for each number separately. Default declarations Using a default declaration , a prorammer can specify a set of natural numbers from which the compiler must choose moduli if a fixed modulus cannot be inferred from the program. If there is no default declaration and the type of the main function contains type variables of kind Nat then a type error occurs as all moduli must be known for compiling and executing the program. Default declarations provide a backdoor to successful compilation even if the main function does not fix all moduli. For instance, suppose that a program contains the following type and default declarations: type N : Nat = 1030307; type M : Nat = 0x1fffffffffffffff; default(127,M,N); The default declaration provides three moduli, one of which is expressed by a literal and others are expressed by type synonyms. The compiler assigns one of the default moduli to each free type variable (all of which are of the kind Nat) of the main function in such a way that all type constraints of the main function meet the predicates of the CCC file that accompanies the compilation. If no such assignment is possible then the compilation fails with a type error. A default declaration must be located in the same file as the main function and there may be at most one of them.","title":"Top Level"},{"location":"3-reference/4-top-level/#top-level-declarations","text":"A ZK-SecreC program is a collection of top-level declarations. The order of the declarations is not important. The declarations can be spread over many files sometimes called modules after modules of code in other programming languages. But please be aware that this term has a potential to be confused with modulus.","title":"Top-Level Declarations"},{"location":"3-reference/4-top-level/#imports","text":"An import brings names exported by another ZK-SecreC module in scope. Otherwise, names defined in a file are visible only throughout the file. For instance, the declaration use Std::*; imports all names exported by the ZK-SecreC module with name Std . To be found, the module must be in file with name Std.zksc either in the same directory as the calling module or in the standard library of ZK-SecreC. Despite the syntax, there is currently no way to import names one-by-one. Names defined at the top level must be unique throughout all the program, including the imported names.","title":"Imports"},{"location":"3-reference/4-top-level/#type-definitions","text":"One can define type synonyms at the top level. The kind of the defined type must be given explicitly. For instance, the declaration type N : Nat = 0x1fffffffffffffff; defines N as a new type synonym that refers to the type-level natural number expressed by the literal 0x1fffffffffffffff (the value of this hexadecimal literal is the Mersenne prime 2 61 -1). Type synonyms can take type arguments, in which case they are in principle functions on types. In a type definition, type parameters are introduced by a comma-separated list in brackets. Any formal type parameter must normally be equipped with its kind using the notation p : k where p is the parameter (a type variable) and k is its kind. However, parameter kinds Stage and Domain can be settled by $ and @ , respectively, preceding the parameter name, in which case the kind name is not written. If the definition starts with the keyword pub then the defined name is exported by the module. Otherwise, the defined name is visible within the current file only, regardless of the imports occurring in other files. For instance, the library file Std.zksc contains the following definitions that introduce type synonyms for types of integers of 8, 16, 32, 64 and 128 bits: pub type u8 : Unqualified = uint[0x100]; pub type u16 : Unqualified = uint[0x10000]; pub type u32 : Unqualified = uint[0x100000000]; pub type u64 : Unqualified = uint[0x10000000000000000]; pub type u128 : Unqualified = uint[0x100000000000000000000000000000000];","title":"Type definitions"},{"location":"3-reference/4-top-level/#struct-declarations","text":"New struct types can also be defined at the top level. A struct declaration introduces the name of the struct type and lists the names of all fields of the structs in this type along with the field types. Type parameters are allowed here, too. For instance, dates are introduced in the standard library with the following struct declaration: pub struct Date[$S, @D, N : Nat] { year : uint[N] $S @D, month : uint[N] $S @D, day : uint[N] $S @D, code : uint[N] $S @D } This declaration introduces a new type with name Date which is parametrized in a stage $S , a domain @D and a type level natural number N . Each element in this type is a data structure containing four fields with names year , month , day and code . All the fields must have the same type uint[N] $S @D , where N , $S and @D are the real types associated to the type parameters. The keyword pub indicates that the name of the type and the names of the fields are exported.","title":"Struct declarations"},{"location":"3-reference/4-top-level/#function-definitions","text":"Like most programming languages, ZK-SecreC allows programmers to define functions.","title":"Function definitions"},{"location":"3-reference/4-top-level/#native-functions","text":"The usual native function definitions have the following syntax: Function = 'pub'? 'sieve'? 'fn' Identifier TypeParams? '(' Params ')' RetType? Constraints? Body RetType = '->' Type Constraints = 'where' TypePreds The modifier pub indicates that the function is exported from the file. Like in the case of functions defined locally, the modifier sieve instructs the function to be compiled as a function gate in Circuit-IR. Without the modifier, no corresponding function in Circuit-IR is created, all calls of this function are inlined, and vectorized applications of the function are impossible. Like type parameters of type synonyms, type parameters of functions are written as a comma separated list in brackets. They introduce polymorphism, i.e., the function can be called with different types (without having to indicate the actual type arguments). The kinds of all type parameters must be explicit. In the case of stage and domain parameters, kind is reflected by the initial character ( $ or @ , respectively). In other cases, kind must be indicated after colon like in N : Nat . A sieve function is not allowed to be stage polymorphic. Ordinary parameters are written as a comma separated list in parentheses. The parameters must be given together with their types. These types can depend on the type parameters introduced earlier. Vectorized application of user defined functions is allowed only if they have been declared as sieve functions, still sieve functions can also be applied in non-vectorized way like usual functions. Parameters of sieve functions that are called in vectorized way must have sized types in order to be put into vectors, and such sieve functions must have at least one parameter. If a sieve function is only called in non-vectorized way then arguments and result values can also be lists whose length is in the public domain. Such function is allowed to have no parameters. The result of applying a sieve function partially non-vectorized is considered a new sieve function: sieve fn f(x : uint[N] $pre @public, y : uint[N] $post @prover) where Field[N] { ... } fn main() where Field[N], Vectorization { let x : uint[N] $pre @public = ...; let ys : arr[uint[N] $post @prover] = ...; let g = f(x); let trash : arr[() $pre @public] = g.(ys); } Note the difference between the sieve modifier and the Vectorization constraint: The former is necessary for the function to be called in vectorized way, whereas the latter is required for the function to be able to call other functions in vectorized way. A function parameter can be preceded by the keyword ref , in which case it is a pass-by-reference parameter, i.e., mutable in the body of the function. Parameters without the keyword ref are immutable. A function with no return type given is assumed to have the return type () . A function may have constraints imposed on its type. If any, constraints are written as a comma-separated list of type predicates after the keyword where . Each type predicate is a condition imposed on types. Standard examples are @D <= @verifier and Field[N] . The former requires the domain-kinded type variable @D to be @verifier at highest, i.e., either @public or @verifier . The latter requires N to be a modulus allowed by the associated CCC file as a field. Note that type predicates do not have to mention type parameters of the function. For instance, N in the last example may be defined as an integer constant outside the function, and even can be replaced with an integer literal in the predicate. Constraints such as ObliviousChoice and Vectorization do not have a parameter at all. Such predicates are reasonable as their truth value can depend on a CCC file which is not part of the ZK-SecreC program. The body of a function must be a block. Throughout the program (including imported modules), there must be exactly one function with name main . The program starts execution from the body of this function. The type of the main function must not contain free type variables, except those of kind Nat .","title":"Native functions"},{"location":"3-reference/4-top-level/#foreign-functions","text":"One can call Rust functions in ZK-SecreC. To this end, the Rust function must be given a corresponding signature in ZK-SecreC. The signature of a foreign function has the same shape as that of a native function, but the keyword extern must occur immediately before the keyword fn . The body must be omitted, e.g., extern fn sqr[@D](x : u64 $pre @D) -> u64 $pre @D; A foreign function cannot be declared as sieve . The Rust functions must be implemented in a Rust file. The -e parameter of runrust specifies the Rust file that implements the foreign functions declared in the ZK-SecreC file. Any Rust compiler errors from that Rust file will reference src/Rust/zksc-app-lib/src/externs.rs , which is where the Rust file is copied to, but the line numbers in the error messages are correct. The following table shows the correspondence between ZK-SecreC and Rust types; here T' denotes the Rust type corresponding to the ZK-SecreC type T : ZK-SecreC Rust () $pre @D () bool $pre @D bool bool[N] $pre @D bool u8 $pre @D u8 u16 $pre @D u16 u32 $pre @D u32 u64 $pre @D u64 u128 $pre @D u128 uint $pre @D BigInt uint[N] $pre @D Value if N is finite and other than 2 n with n =8,16,32,64,128 string $pre @D String T : Qualified Value list[() $pre @D] Value arr[() $pre @D] Value list[T] or arr[T] Vec<T'> if T' is bool , u8 , u16 , u32 , u64 , u128 list[T] or arr[T] Vec<Value> if T' is not () , bool , u8 , u16 , u32 , u64 , u128 tuple[T1,T2] (T1',T2') if not a pass-by-reference argument tuple[T1,T2,T3] (T1',T2',T3') if not a pass-by-reference argument tuple[T1,T2,T3,T4] (T1',T2',T3',T4') if not a pass-by-reference parameter tuple[T1,T2,T3,T4,T5] (T1',T2',T3',T4',T5') if not a pass-by-reference parameter tuple[T1,...,Tn] Box<[Value]> struct Box<[Value]> store[T1,T2] $S @D Value For non-primitive Rust types other than tuples, i.e. for Value , Vec , Box , BigInt , String , the Rust type must be prefixed by & when used for an argument of an foreign function (e.g. &Value instead of Value ) but not when used for a return value. The prefix is also used inside tuples (e.g. ( &Value , &BigInt )). Primitive Rust types and Rust tuples are not prefixed when used as non-ref parameters. For pass-by-reference parameters, the prefix is &mut . Rust tuples (e.g. ( &mut Value , &mut BigInt )) cannot be used for pass-by-reference parameters, instead &mut Box<[Value]> (or &mut Value ) must be used regardless of the number of components. Primitive Rust types are prefixed with &mut when used as pass-by-reference parameters. All the prefixed (borrowed) values can be cloned (using the method clone() in Rust) to get the non-prefixed (owned) value. This cloning is constant-time for Value (only increasing the reference count) but makes a copy of the whole data structure for Vec , Box , BigInt , and String . To avoid this copying, it is also possible to use Value ( &Value for pass-by-value parameters, &mut Value for pass-by-reference parameters) instead of these types when defining the Rust function. The Value , &Value , and &mut Value can be converted to/from the corresponding Rust types using the From and Into traits. The into() method is essential when implementing external functions on multidimensional lists/arrays or lists/arrays of tuples/BigInts/strings, as lists/arrays with non-primitive elements are always represented as Vec<Value> and the into() method needs to be used to convert the elements to/from the corresponding Rust types. It is also needed for tuples translated as Box<[Value]> . Slices cannot be passed to foreign functions. They can be removed (copying the elements of the slice to a new list/array) using the builtin function unslice (e.g., unslice(xs[1..]) instead of xs[1..] ).","title":"Foreign functions"},{"location":"3-reference/4-top-level/#implementing-external-rust-functions","text":"The module crate::externs_header , which re-exports some essential types, needs to be imported in every Rust file implementing functions used as ZK-SecreC foreign functions: use crate::externs_header::*; External function implementations must use the pub keyword, so that they can be used from the ZK-SecreC code. The first two parameters must be of types &ContextRef and &mut Stack , the variables can be _ as they are usually not needed. The next parameters are the type parameters (other than Unqualified ) of the ZK-SecreC function, the Rust type depends on the kind of the ZK-SecreC type parameter according to the following table: ZK-SecreC Rust domain ( @ ) DomainType stage ( $ ) StageType Nat &NatType Qualified QualifiedType Unqualified (no parameter) After that, there will be the ordinary parameters of the ZK-SecreC function. For the example foreign function sqr , we can have the following Rust implementation: pub fn sqr(_: &ContextRef, _: &mut Stack, _d: DomainType, x: u64) -> u64 { x * x } Here, we have _d: DomainType corresponding to the @D in ZK-SecreC and x: u64 corresponding to x : u64 $pre @D in ZK-SecreC. The variable names do not have to be the same as in ZK-SecreC.","title":"Implementing external Rust functions"},{"location":"3-reference/4-top-level/#effect-declarations","text":"For guaranteeing preservation of privacy, static types are not enough. Besides types, the compiler of ZK-SecreC must keep track of effects . One can read more about effects in the Type system subsection. In brief, effects encode any medium (a word chosen to be maximally abstract) where an operation can cause observable changes (apart from the return value). Here, we need to know that there are stage effects and domain effects (besides others). In most cases, the compiler is able to infer effects, but sometimes (typically in the case of recursive functions) it fails to do it. The programmer can document effects of any functions in an effect declaration . If present, the effect declaration must be put directly before the function declaration. An effect declaration has the following syntax: EffectDecl = 'unchecked' 'eff' EffType '!' Effs Effs = Eff | Eff '+' Effs Eff = Stage | Domain Here, EffType is a sketch of the type of the function and Effs is a list of effects potentially arising during an execution of the function body. Only stage effects and domain effects can be given, with plus sign separating them. The type parameters of the function can be used in the effects. For instance, the auxiliary function sum in the subsection Getting Started of this documentation could have the following effect declaration: unchecked eff * -> * ! $S Lists and vectors can be indicated by brackets, so one could make the type sketch more precise by writing unchecked eff [*] -> * ! $S Similarly, a tuple type can be indicated by comma-separated sketches of the component types in brackets.","title":"Effect declarations"},{"location":"3-reference/4-top-level/#implementation-declarations","text":"An implementation declaration introduces functions associated to a struct type. It is of the form impl s { ... } where s is a struct type name (that must be defined separately by a struct declaration) and the braces contain definitions of functions associated to the struct type. The function definitions in an implementation declaration have the same syntax and semantics as function definitions at the top level. The designers of implementation declarations initially had the aim of introducing object-oriented features into ZK-SecreC. Functions associated to struct types should have played the role of methods. Currently, these aims are not fully implemented. Functions defined in implementation declarations cannot be called explicitly. However, as a builtin feature, the function with name finalize , if present in the implementation declaration, is called on each struct of that type when it goes out of scope. The function finalize must take one parameter which has the corresponding struct type and its return type must be () $pre @public . This special feature firstly serves the aim of code modularization. A programmer can specify all boring checks concerning the struct in the finalizer where they do not disturb understanding the logic of the main functionality. Secondly, postponing all checks concerning a data item to the end of its lifetime sometimes enables the checks to be performed more efficiently because checking correctness of many operations together may allow optimizations compared to the checking of every operation separately. This is so in the case of store operations (reads and writes) and also in the case of inequalities of integers. This is the reason why comparison operations at the post stage implemented in the standard library require a supplementary data structure, a size asserter. The size asserter is a struct that collects information about numbers for which it must be checked that their binary representation uses at most a certain number of bits. Checking this for many integers together can be performed more efficiently than checking this for each number separately.","title":"Implementation declarations"},{"location":"3-reference/4-top-level/#default-declarations","text":"Using a default declaration , a prorammer can specify a set of natural numbers from which the compiler must choose moduli if a fixed modulus cannot be inferred from the program. If there is no default declaration and the type of the main function contains type variables of kind Nat then a type error occurs as all moduli must be known for compiling and executing the program. Default declarations provide a backdoor to successful compilation even if the main function does not fix all moduli. For instance, suppose that a program contains the following type and default declarations: type N : Nat = 1030307; type M : Nat = 0x1fffffffffffffff; default(127,M,N); The default declaration provides three moduli, one of which is expressed by a literal and others are expressed by type synonyms. The compiler assigns one of the default moduli to each free type variable (all of which are of the kind Nat) of the main function in such a way that all type constraints of the main function meet the predicates of the CCC file that accompanies the compilation. If no such assignment is possible then the compilation fails with a type error. A default declaration must be located in the same file as the main function and there may be at most one of them.","title":"Default declarations"},{"location":"3-reference/6-boxed-and-unboxed-types/","text":"Boxed and unboxed types Primitive Types Values of most types in ZK-SecreC are reference counted, making them cheap to clone by just increasing the reference count instead of making a deep copy of the data structure. However, for basic integers and booleans in the $pre domain, the overhead of reference counting is much larger than the cost of actually doing arithmetic or boolean operations on them, making those operations up to 2 orders of magnitude slower than they are in Rust. For this reason, integers of the types uint[ 2 n ] where n =8,16,32,64,128 are compiled to integers of Rust types u8 , u16 , u32 , u64 and u128 , respectively. These types, as well as all boolean types, do not have reference counting. Arithmetic, boolean, and comparison operations on them have speeds close to those of the corresponding operations in Rust. Primitive types can be domain polymorphic or have a fixed domain (e.g. @prover ). The types must be known to be in the $pre stage at compile time. If they are stage polymorphic then they will be reference counted even if they are in the $pre stage during run time. Booleans can also be polymorphic in the modulus but integers must have the modulus known at compile time, otherwise they will be reference counted. The following operations on primitive types have speed close to the corresponding operations in Rust: Arithmetic operations + , - , * , / , % Comparison operations == , != , < , <= , > , >= Boolean operations & , | , xor , ! Vectors and lists In this section the term array is used to include both ZK-SecreC vectors ( arr[...] ) and lists ( list[...] ). Arrays in ZK-SecreC can be internally boxed or unboxed, although there is no difference in the type of the array. Boxed arrays have each element separately reference counted, causing much more overhead when accessing the elements. The elements of boxed arrays can be of non-primitive or primitive type. Unboxed arrays do not have each element separately reference counted and the elements can only be of primitive type. All primitive types can be used as elements of unboxed arrays. Both boxed and unboxed arrays as a whole (as opposed to their individual elements) are always reference counted. If an array is created and its element type is known to be primitive at compile time then the array will automatically be unboxed. If the element type is not known to be primitive at compile time (e.g., in polymorphic functions) then the array will be boxed, even if the element type will actually be primitive during run time. Boxed and unboxed arrays can be used interchangeably in ZK-SecreC native code, i.e., an unboxed array can be given as an argument to a polymorphic function that expects a boxed array and a boxed array of primitive values returned from a polymorphic function can be used in a non-polymorphic code that expects an unboxed array. Whole arrays are not automatically converted from boxed to unboxed type or vice versa. Instead, individual elements of the array are converted between reference counted and primitive types as needed. This can cause some extra overhead. A for loop can be used to make a copy of an array with optimal boxedness for the current scope. However, boxed arrays of primitive types cannot be passed to foreign functions.","title":"Boxed and Unboxed Types"},{"location":"3-reference/6-boxed-and-unboxed-types/#boxed-and-unboxed-types","text":"","title":"Boxed and unboxed types"},{"location":"3-reference/6-boxed-and-unboxed-types/#primitive-types","text":"Values of most types in ZK-SecreC are reference counted, making them cheap to clone by just increasing the reference count instead of making a deep copy of the data structure. However, for basic integers and booleans in the $pre domain, the overhead of reference counting is much larger than the cost of actually doing arithmetic or boolean operations on them, making those operations up to 2 orders of magnitude slower than they are in Rust. For this reason, integers of the types uint[ 2 n ] where n =8,16,32,64,128 are compiled to integers of Rust types u8 , u16 , u32 , u64 and u128 , respectively. These types, as well as all boolean types, do not have reference counting. Arithmetic, boolean, and comparison operations on them have speeds close to those of the corresponding operations in Rust. Primitive types can be domain polymorphic or have a fixed domain (e.g. @prover ). The types must be known to be in the $pre stage at compile time. If they are stage polymorphic then they will be reference counted even if they are in the $pre stage during run time. Booleans can also be polymorphic in the modulus but integers must have the modulus known at compile time, otherwise they will be reference counted. The following operations on primitive types have speed close to the corresponding operations in Rust: Arithmetic operations + , - , * , / , % Comparison operations == , != , < , <= , > , >= Boolean operations & , | , xor , !","title":"Primitive Types"},{"location":"3-reference/6-boxed-and-unboxed-types/#vectors-and-lists","text":"In this section the term array is used to include both ZK-SecreC vectors ( arr[...] ) and lists ( list[...] ). Arrays in ZK-SecreC can be internally boxed or unboxed, although there is no difference in the type of the array. Boxed arrays have each element separately reference counted, causing much more overhead when accessing the elements. The elements of boxed arrays can be of non-primitive or primitive type. Unboxed arrays do not have each element separately reference counted and the elements can only be of primitive type. All primitive types can be used as elements of unboxed arrays. Both boxed and unboxed arrays as a whole (as opposed to their individual elements) are always reference counted. If an array is created and its element type is known to be primitive at compile time then the array will automatically be unboxed. If the element type is not known to be primitive at compile time (e.g., in polymorphic functions) then the array will be boxed, even if the element type will actually be primitive during run time. Boxed and unboxed arrays can be used interchangeably in ZK-SecreC native code, i.e., an unboxed array can be given as an argument to a polymorphic function that expects a boxed array and a boxed array of primitive values returned from a polymorphic function can be used in a non-polymorphic code that expects an unboxed array. Whole arrays are not automatically converted from boxed to unboxed type or vice versa. Instead, individual elements of the array are converted between reference counted and primitive types as needed. This can cause some extra overhead. A for loop can be used to make a copy of an array with optimal boxedness for the current scope. However, boxed arrays of primitive types cannot be passed to foreign functions.","title":"Vectors and lists"},{"location":"4-api/BigInt/","text":"","title":"BigInt"},{"location":"4-api/Bitextract/","text":"","title":"Bitextract"},{"location":"4-api/Builtin/","text":"","title":"Builtin"},{"location":"4-api/Char/","text":"","title":"Char"},{"location":"4-api/ChrVec/","text":"","title":"ChrVec"},{"location":"4-api/DFA/","text":"","title":"DFA"},{"location":"4-api/Date/","text":"","title":"Date"},{"location":"4-api/EC/","text":"","title":"EC"},{"location":"4-api/FastFixedPoint/","text":"","title":"FastFixedPoint"},{"location":"4-api/FastFixedPointVec/","text":"","title":"FastFixedPointVec"},{"location":"4-api/FixedPoint/","text":"","title":"FixedPoint"},{"location":"4-api/Inequalities/","text":"","title":"Inequalities"},{"location":"4-api/Integer/","text":"","title":"Integer"},{"location":"4-api/IsFromFirst/","text":"","title":"IsFromFirst"},{"location":"4-api/OldInequalities/","text":"","title":"OldInequalities"},{"location":"4-api/Perm/","text":"","title":"Perm"},{"location":"4-api/Poseidon/","text":"","title":"Poseidon"},{"location":"4-api/Prob/","text":"","title":"Prob"},{"location":"4-api/SetOp/","text":"","title":"SetOp"},{"location":"4-api/Std/","text":"","title":"Std"},{"location":"4-api/Store/","text":"","title":"Store"},{"location":"4-api/StoreVec/","text":"","title":"StoreVec"},{"location":"4-api/String/","text":"","title":"String"},{"location":"4-api/Text/","text":"","title":"Text"},{"location":"4-api/Vec/","text":"","title":"Vec"},{"location":"4-api/Waksman/","text":"","title":"Waksman"},{"location":"5-backend-interface/0-interfacing-a-new-backend/","text":"Interfacing the ZK-SecreC Compiler with ZK Backends When the ZK-SecreC compiler compiles a ZK-SecreC program, it can produce a circuit in a certain IR but it can also call a ZK backend (which executes the ZK protocols) directly. Support for new backends (either backends producing a different IR or backends executing the ZK protocols) can be added to the ZK-SecreC compiler by implementing a certain Rust trait for that backend. The trait is called SIEVEIR and is defined in src/Rust/zksc-app-lib/src/sieve.rs . The dummy backend There is a simple implementation of the SIEVEIR trait that can be used as an example when implementing the trait for a new backend. This simple backend is called the dummy backend and is implemented in src/Rust/zksc-dummy/src/main.rs . It runs the circuit operations locally instead of executing ZK protocols or generating IR. It also makes many correctness checks but is not optimized for efficiency, so it may be slow. The trait for wires There is a notion of wire , meaning a scalar value that is on a circuit, i.e. a scalar value that is in $post stage. Each backend may handle wires differently. For example, backends producing an IR may have unique number for each wire, while backends executing ZK protocols may have a certain structure in memory to represent each wire. There is a trait WireTrait , defined in sieve.rs , that must be implemented for each backend according to how it represents wires internally. There is also a struct Wire , which is a trait object of the trait WireTrait . Objects of the type Wire are given as arguments and returned from many methods of the SIEVEIR trait. Implementing WireTrait for a datatype that represents the wire internally is not difficult. The datatype must derive the Debug trait and implement WireTrait as follows (where WireImpl is the datatype representing the wire): impl WireTrait for WireImpl { fn to_any(&self) -> &dyn Any { self as &dyn Any } } The implementation of to_any is the same for each datatype but it cannot be made into a default implementation because then it would convert the polymorphic type ( &dyn WireTrait ) rather than the monomorphic type ( &WireImpl ) into &dyn Any and then it cannot be converted back to the monomorphic type &WireImpl . When implementing methods of the SIEVEIR trait that take as argument or return objects of type Wire , it is usually necessary to convert the objects from type Wire to the concrete type implementing WireTrait , as well as back from the concrete type to Wire . Converting from the concrete type to Wire can be done using the polymorphic function upcast_wire , defined in sieve.rs . The function that converts from Wire to the concrete type needs to be defined for each concrete type separately as follows: fn downcast_wire(w: &Wire) -> &WireImpl { w.downcast::<WireImpl>() } where WireImpl is the concrete type implementing WireTrait . There is also a function upcast_wires (and downcast_wires if defined for the given type), converting vectors of wires instead of single wires. Wire ranges There is also a notion of wire range , meaning a vector of wires, i.e. a vector of scalar values in the $post stage. Wire ranges may also be handled differently in each backend. For example, backends producing an IR may have a contiguous range of numbers for each wire in the wire range, while backends executing ZK protocols may have some structure in memory that is more efficient than having a separate data structure for each wire in the wire range. There is a trait WireRangeTrait , defined in sieve.rs , that must be implemented for each backend that supports wire ranges. Supporting wire ranges is not compulsory but is recommended for efficiency. The ZK-SecreC compiler supports automatic unrolling of vectorized operations, which replaces wire ranges with the individual wires in the range, and can be used for backends that do not support wire ranges. Similarly to wires, there is also a struct WireRange , which is a trait object of the trait WireRangeTrait . Objects of the type WireRange are given as arguments and returned from several methods of the SIEVEIR trait. Implementing WireRangeTrait for a datatype that represents the wire internally is similar to implementing WireTrait . The datatype must derive the Debug trait and implement the method to_any in the same way as for WireTrait . In addition, it must implement the method length that returns the number of wires in a wire range. Converting from a concrete type implementing WireRangeTrait to WireRange and back is similar to wires, using upcast_wr , defined in sieve.rs , and downcast_wr , defined for each concrete type as follows: fn downcast_wr(wr: &WireRange) -> &WireRangeImpl { wr.downcast::<WireRangeImpl>() } where WireRangeImpl is the concrete type implementing WireRangeTrait . There is also a function upcast_wrs (and downcast_wrs if defined for the given type), converting vectors of wire ranges instead of single wire ranges. Types used in SIEVEIR method signatures Many of the arguments and return values of the methods of the SIEVEIR trait are of types that are defined in the Rust part of the ZK-SecreC compiler, rather than standard Rust types. The types Wire and WireRange were described above. The type IndexRange is described under the method slice_wire_range , which is the only method where it is used. The other types are described here. The type Integer Integer is a type synonym (defined in integer.rs ) for BigInt from num_bigint . It is used for integer constant arguments of SIEVEIR methods. The type Value The type Value represents any ZK-SecreC value but here it is assumed to be a scalar (integer or boolean) $pre value. It is used for values that are added to instance or witness streams (and from there to wires), or for public constants loaded directly onto wires. It is a reference-counted object that can be cloned in constant time to turn &Value into Value if necessary. It is possible to branch over whether the value v: &Value with modulus m: &NatType is an integer or a boolean and extract the value as a bool or a BigInt , using match v.view() { ValueView::ZkscDefined() => { /* integer with value n: BigInt */ let n: BigInt = (m.to_bigint)(v); ... } ValueView::Bool(b) => { /* boolean with value b: bool */ ... } _ => panic!(\"Not an integer or boolean\"), } The type NatType is described in the next section. Here we use the method to_bigint of the modulus m: &NatType . Other methods of NatType can also be used to handle values of type Value . The full definition of Value (in value.rs ) is complex and is not needed to implement the SIEVEIR trait, so it will be omitted here. The type NatType NatType denotes a modulus of wires and values, including inputs and outputs of sieve functions and plugins. It is defined in zksc_types.rs as a struct with methods as its fields: pub struct NatType { pub tag: u64, pub modulus: Option<BigInt>, pub modulus_value: fn() -> Value, pub modulus_limbs_le: Option<&'static [usize]>, pub is_zero : fn(&Value) -> bool, pub is_one : fn(&Value) -> bool, pub eq : fn(&Value, &Value) -> bool, pub lt : fn(&Value, &Value) -> bool, pub add : fn(&Value, &Value) -> Value, pub mul : fn(&Value, &Value) -> Value, pub sub : fn(&Value, &Value) -> Value, pub div: fn(&Value, &Value) -> Value, pub hmod: fn(&Value,&Value) -> Value, pub mod_div : fn(&Value,&Value) -> Value, pub to_bigint: fn(&Value) -> Integer, pub from_bigint: fn(&Integer) -> Value, pub fmt: fn(&Value, &mut fmt::Formatter<'_>) -> fmt::Result, pub from_limbs_le: fn(&[usize]) -> Value, } For implementing the SIEVEIR trait, only the method to_bigint and the fields modulus and tag are useful. The method to_bigint was used in the previous section about Value and extracts the integer from a &Value . The field modulus contains Some(m) where m is the modulus as a BigInt if the modulus is finite. If the modulus is infinite then modulus is None but this should not occur with the moduli given to SIEVEIR trait methods since these moduli are used in the circuit. The field tag is different for each modulus used in the ZK-SecreC program and can be used to check more efficiently whether two moduli are equal by comparing the u64 tags instead of the BigInt moduli. The type WireOrConst The enum WireOrConst is used for creating a vector or returning values from a function and is defined in sieve.rs as follows: pub enum WireOrConst<'a> { W(&'a Wire), C(Integer), } allowing each value in the vector or returned from a function to either be copied from an existing wire or be a constant. The type Allocation The type Allocation is a trait object of the trait AllocationTrait (defined in sieve.rs ), similarly to Wire and WireRange . It is used for backends that support allocating a wire range without immediately assigning values to the wires in the range. The following SIEVEIR method calls that return new wires will take those wires from this allocated range until all wires of the range have been assigned values. The wire range can be deallocated as a whole when all wires in the range have gone out of scope. Implementing AllocationTrait and the methods that use the type Allocation is optional.","title":"Interfacing a New Backend"},{"location":"5-backend-interface/0-interfacing-a-new-backend/#interfacing-the-zk-secrec-compiler-with-zk-backends","text":"When the ZK-SecreC compiler compiles a ZK-SecreC program, it can produce a circuit in a certain IR but it can also call a ZK backend (which executes the ZK protocols) directly. Support for new backends (either backends producing a different IR or backends executing the ZK protocols) can be added to the ZK-SecreC compiler by implementing a certain Rust trait for that backend. The trait is called SIEVEIR and is defined in src/Rust/zksc-app-lib/src/sieve.rs .","title":"Interfacing the ZK-SecreC Compiler with ZK Backends"},{"location":"5-backend-interface/0-interfacing-a-new-backend/#the-dummy-backend","text":"There is a simple implementation of the SIEVEIR trait that can be used as an example when implementing the trait for a new backend. This simple backend is called the dummy backend and is implemented in src/Rust/zksc-dummy/src/main.rs . It runs the circuit operations locally instead of executing ZK protocols or generating IR. It also makes many correctness checks but is not optimized for efficiency, so it may be slow.","title":"The dummy backend"},{"location":"5-backend-interface/0-interfacing-a-new-backend/#the-trait-for-wires","text":"There is a notion of wire , meaning a scalar value that is on a circuit, i.e. a scalar value that is in $post stage. Each backend may handle wires differently. For example, backends producing an IR may have unique number for each wire, while backends executing ZK protocols may have a certain structure in memory to represent each wire. There is a trait WireTrait , defined in sieve.rs , that must be implemented for each backend according to how it represents wires internally. There is also a struct Wire , which is a trait object of the trait WireTrait . Objects of the type Wire are given as arguments and returned from many methods of the SIEVEIR trait. Implementing WireTrait for a datatype that represents the wire internally is not difficult. The datatype must derive the Debug trait and implement WireTrait as follows (where WireImpl is the datatype representing the wire): impl WireTrait for WireImpl { fn to_any(&self) -> &dyn Any { self as &dyn Any } } The implementation of to_any is the same for each datatype but it cannot be made into a default implementation because then it would convert the polymorphic type ( &dyn WireTrait ) rather than the monomorphic type ( &WireImpl ) into &dyn Any and then it cannot be converted back to the monomorphic type &WireImpl . When implementing methods of the SIEVEIR trait that take as argument or return objects of type Wire , it is usually necessary to convert the objects from type Wire to the concrete type implementing WireTrait , as well as back from the concrete type to Wire . Converting from the concrete type to Wire can be done using the polymorphic function upcast_wire , defined in sieve.rs . The function that converts from Wire to the concrete type needs to be defined for each concrete type separately as follows: fn downcast_wire(w: &Wire) -> &WireImpl { w.downcast::<WireImpl>() } where WireImpl is the concrete type implementing WireTrait . There is also a function upcast_wires (and downcast_wires if defined for the given type), converting vectors of wires instead of single wires.","title":"The trait for wires"},{"location":"5-backend-interface/0-interfacing-a-new-backend/#wire-ranges","text":"There is also a notion of wire range , meaning a vector of wires, i.e. a vector of scalar values in the $post stage. Wire ranges may also be handled differently in each backend. For example, backends producing an IR may have a contiguous range of numbers for each wire in the wire range, while backends executing ZK protocols may have some structure in memory that is more efficient than having a separate data structure for each wire in the wire range. There is a trait WireRangeTrait , defined in sieve.rs , that must be implemented for each backend that supports wire ranges. Supporting wire ranges is not compulsory but is recommended for efficiency. The ZK-SecreC compiler supports automatic unrolling of vectorized operations, which replaces wire ranges with the individual wires in the range, and can be used for backends that do not support wire ranges. Similarly to wires, there is also a struct WireRange , which is a trait object of the trait WireRangeTrait . Objects of the type WireRange are given as arguments and returned from several methods of the SIEVEIR trait. Implementing WireRangeTrait for a datatype that represents the wire internally is similar to implementing WireTrait . The datatype must derive the Debug trait and implement the method to_any in the same way as for WireTrait . In addition, it must implement the method length that returns the number of wires in a wire range. Converting from a concrete type implementing WireRangeTrait to WireRange and back is similar to wires, using upcast_wr , defined in sieve.rs , and downcast_wr , defined for each concrete type as follows: fn downcast_wr(wr: &WireRange) -> &WireRangeImpl { wr.downcast::<WireRangeImpl>() } where WireRangeImpl is the concrete type implementing WireRangeTrait . There is also a function upcast_wrs (and downcast_wrs if defined for the given type), converting vectors of wire ranges instead of single wire ranges.","title":"Wire ranges"},{"location":"5-backend-interface/0-interfacing-a-new-backend/#types-used-in-sieveir-method-signatures","text":"Many of the arguments and return values of the methods of the SIEVEIR trait are of types that are defined in the Rust part of the ZK-SecreC compiler, rather than standard Rust types. The types Wire and WireRange were described above. The type IndexRange is described under the method slice_wire_range , which is the only method where it is used. The other types are described here.","title":"Types used in SIEVEIR method signatures"},{"location":"5-backend-interface/0-interfacing-a-new-backend/#the-type-integer","text":"Integer is a type synonym (defined in integer.rs ) for BigInt from num_bigint . It is used for integer constant arguments of SIEVEIR methods.","title":"The type Integer"},{"location":"5-backend-interface/0-interfacing-a-new-backend/#the-type-value","text":"The type Value represents any ZK-SecreC value but here it is assumed to be a scalar (integer or boolean) $pre value. It is used for values that are added to instance or witness streams (and from there to wires), or for public constants loaded directly onto wires. It is a reference-counted object that can be cloned in constant time to turn &Value into Value if necessary. It is possible to branch over whether the value v: &Value with modulus m: &NatType is an integer or a boolean and extract the value as a bool or a BigInt , using match v.view() { ValueView::ZkscDefined() => { /* integer with value n: BigInt */ let n: BigInt = (m.to_bigint)(v); ... } ValueView::Bool(b) => { /* boolean with value b: bool */ ... } _ => panic!(\"Not an integer or boolean\"), } The type NatType is described in the next section. Here we use the method to_bigint of the modulus m: &NatType . Other methods of NatType can also be used to handle values of type Value . The full definition of Value (in value.rs ) is complex and is not needed to implement the SIEVEIR trait, so it will be omitted here.","title":"The type Value"},{"location":"5-backend-interface/0-interfacing-a-new-backend/#the-type-nattype","text":"NatType denotes a modulus of wires and values, including inputs and outputs of sieve functions and plugins. It is defined in zksc_types.rs as a struct with methods as its fields: pub struct NatType { pub tag: u64, pub modulus: Option<BigInt>, pub modulus_value: fn() -> Value, pub modulus_limbs_le: Option<&'static [usize]>, pub is_zero : fn(&Value) -> bool, pub is_one : fn(&Value) -> bool, pub eq : fn(&Value, &Value) -> bool, pub lt : fn(&Value, &Value) -> bool, pub add : fn(&Value, &Value) -> Value, pub mul : fn(&Value, &Value) -> Value, pub sub : fn(&Value, &Value) -> Value, pub div: fn(&Value, &Value) -> Value, pub hmod: fn(&Value,&Value) -> Value, pub mod_div : fn(&Value,&Value) -> Value, pub to_bigint: fn(&Value) -> Integer, pub from_bigint: fn(&Integer) -> Value, pub fmt: fn(&Value, &mut fmt::Formatter<'_>) -> fmt::Result, pub from_limbs_le: fn(&[usize]) -> Value, } For implementing the SIEVEIR trait, only the method to_bigint and the fields modulus and tag are useful. The method to_bigint was used in the previous section about Value and extracts the integer from a &Value . The field modulus contains Some(m) where m is the modulus as a BigInt if the modulus is finite. If the modulus is infinite then modulus is None but this should not occur with the moduli given to SIEVEIR trait methods since these moduli are used in the circuit. The field tag is different for each modulus used in the ZK-SecreC program and can be used to check more efficiently whether two moduli are equal by comparing the u64 tags instead of the BigInt moduli.","title":"The type NatType"},{"location":"5-backend-interface/0-interfacing-a-new-backend/#the-type-wireorconst","text":"The enum WireOrConst is used for creating a vector or returning values from a function and is defined in sieve.rs as follows: pub enum WireOrConst<'a> { W(&'a Wire), C(Integer), } allowing each value in the vector or returned from a function to either be copied from an existing wire or be a constant.","title":"The type WireOrConst"},{"location":"5-backend-interface/0-interfacing-a-new-backend/#the-type-allocation","text":"The type Allocation is a trait object of the trait AllocationTrait (defined in sieve.rs ), similarly to Wire and WireRange . It is used for backends that support allocating a wire range without immediately assigning values to the wires in the range. The following SIEVEIR method calls that return new wires will take those wires from this allocated range until all wires of the range have been assigned values. The wire range can be deallocated as a whole when all wires in the range have gone out of scope. Implementing AllocationTrait and the methods that use the type Allocation is optional.","title":"The type Allocation"},{"location":"5-backend-interface/1-trait-methods/","text":"SIEVEIR Trait Methods Here we will describe the methods of the SIEVEIR trait, which can be implemented when interfacing a new backend with the ZK-SecreC compiler. Some of the methods are required for all backends, some are optional. Arithmetic and boolean operations All of these methods are required. The parameter m is the modulus of the wires, represented with the type NatType . Constants are of the type Integer , which is a type synonym for BigInt from num_bigint . Method and fn and(&self, m: &NatType, w1: &Wire, w2: &Wire) -> Wire; Logical conjunction. Method xor fn xor(&self, m: &NatType, w1: &Wire, w2: &Wire) -> Wire; Logical exclusive or. Method not fn not(&self, m: &NatType, w1: &Wire) -> Wire; Logical negation. Method mul fn mul(&self, m: &NatType, w1: &Wire, w2: &Wire) -> Wire; Modular multiplication. Method add fn add(&self, m: &NatType, w1: &Wire, w2: &Wire) -> Wire; Modular addition. Method mulc fn mulc(&self, m: &NatType, w1: &Wire, c2: &Integer) -> Wire; Modular multiplication between value on wire and constant value. Method addc fn addc(&self, m: &NatType, w1: &Wire, c2: &Integer) -> Wire; Modular addition between value on wire and constant value. Using instance and witness streams These are not strictly required but strongly recommended as otherwise instances and witnesses cannot be used. The methods get_instance_wr and get_witness_wr are not required if the backend does not support wire ranges. The type Value represents any ZK-SecreC value but here it is assumed to be a scalar $pre value. Method add_instance fn add_instance(&self, m: &NatType, x: &Value); Add a new value x to the instance stream of modulus m . Method get_instance Add a new value x to the instance stream of modulus m . fn get_instance(&self, m: &NatType) -> Wire; Get value of a new wire from the instance stream of modulus m . This function is called sequentially so n-th call loads the n-th value from the instance. The value must be added to the instance using add_instance before it can be read with get_instance or get_instance_wr . Method get_instance_wr fn get_instance_wr(&self, m: &NatType, n: usize) -> WireRange; Get n values from instance to a new wire range. This is equivalent to calling get_instance n times but may be more efficient if the backend supports vectorized get_instance . The n values must be added to the instance stream using add_instance before they can be read with get_instance_wr . Method add_witness fn add_witness(&self, m: &NatType, x: &Value); Add a new value x to the witness stream of modulus m . Method get_witness fn get_witness(&self, m: &NatType) -> Wire; Get value of a new wire from the witness stream of modulus m . This function is called sequentially so n-th call loads the n-th value from the witness. The value must be added to the witness using add_witness before it can be read with get_witness or get_witness_wr . Method get_witness_wr fn get_witness_wr(&self, m: &NatType, n: usize) -> WireRange; Get n values from witness to a new wire range. This is equivalent to calling get_witness n times but may be more efficient if the backend supports vectorized get_witness . The n values must be added to the witness stream using add_witness before they can be read with get_witness_wr . Assertions and field switches Of these, only assert_zero and assert_eq_scalar_vec are required. Method assert_zero fn assert_zero(&self, m: &NatType, w: &Wire); Assert that the value on the wire is zero. Method assert_eq fn assert_eq(&self, m1: &NatType, w1: &Wire, m2: &NatType, w2: &Wire); Assert that values on two wires (of different moduli) are equal. Method assert_eq_scalar_vec fn assert_eq_scalar_vec(&self, m1: &NatType, w1: &Wire, m2: &NatType, wires: Vec<Wire>); Assert that the value of w1 has binary representation based on values of wires . value(w1) = value(wires[0]) + 2*value(wires[1]) + 4*value(wires[2]) + ... Used for more efficiently implemementing boolean circuit evaluation. Method bool2int fn bool2int(&self, m: &NatType, w1: &Wire, output_modulus: &NatType) -> Wire; Convert a boolean wire of modulus m to an integer wire of modulus output_modulus . Method int_field_switch fn int_field_switch(&self, m: &NatType, w1: &Wire, output_modulus: &NatType) -> Wire; Switch the field of w1 to new modulus m . For conversion of boolean to uint we use bool2int calls instead. Constants, cloning, copying, and dropping wires Of these methods, const_bool , zero_wire , clone_wire , and drop_wire are required. Method const_bool fn const_bool(&self, m: &NatType, b: bool) -> Wire; Load a constant boolean onto a fresh wire. Method const_uint fn const_uint(&self, m: &NatType, x: &Value) -> Wire; Load a constant integer onto a fresh wire. Similar to add_instance + get_instance and add_witness + get_witness but for public values. Method zero_wire fn zero_wire(&self, m: &NatType) -> Wire; Construct wire that won't be used. Method clone_wire fn clone_wire(&self, w1: &Wire) -> Wire; Clone a wire. Both input and output wire will be deallocated separately. If the underlying wire representation is a raw pointer the clone will have to either copy the pointed data or deal with reference counting. Input and output have the same modulus. Method copy_bool fn copy_bool(&self, m: &NatType, w1: &Wire) -> Wire; Semantically identical to clone_wire where wires have modulus 2 . Internally used to make sure that textual IR1 output is identical to our earlier versions. Method drop_wire fn drop_wire(&self, wire: &mut Wire); Deallocate a wire. Called automatically when the wire goes out of scope. This method should free any memory that is not freed automatically. Handling wire ranges The methods declare_new_wire_range and declare_delete_wire_range are optional and are not called from the frontend, they are intended to be called from the backend itself. They are used only by backends that implement AllocationTrait . The other methods are required only if the backend supports wire ranges. Method zero_wire_range fn zero_wire_range(&self, m: &NatType, n: usize) -> WireRange; Construct a wire range of length n that won't be used. Method clone_wire_range fn clone_wire_range(&self, wr: &WireRange) -> WireRange; Clone a range of wires. Method index_wire_range fn index_wire_range(&self, wr: &WireRange, i: usize) -> Wire; Index a range of wires, returning the wire with index i . The first wire in a range has index 0 . Method slice_wire_range fn slice_wire_range(&self, wr: &WireRange, ir: &IndexRange) -> WireRange; Slice a range of wires. The struct IndexRange is defined in sieve.rs as follows: pub struct IndexRange { pub first: usize, pub length: usize, } giving the index of the first wire and the length of the slice. Method wire_to_wire_range fn wire_to_wire_range(&self, w: &Wire) -> WireRange; Convert a wire into a length-1 wire range. Method drop_wire_range fn drop_wire_range(&self, wr: &mut WireRange); Drop a wire range. Called automatically when the wire range goes out of scope. This method should free any memory that is not freed automatically. Method create_vector fn create_vector(&self, m: &NatType, wocs: Vec<WireOrConst>) -> WireRange; Copy wires or constant values to fresh wires in a wire range, so that they can be used in vectorized operations. Method declare_new_wire_range fn declare_new_wire_range(&self, alloc: &Allocation); Allocate a range of wires. Method declare_delete_wire_range fn declare_delete_wire_range(&self, alloc: &Allocation); Deallocate a range of wires. Sieve functions and plugins These methods are optional. Functions defined with the sieve keyword in ZK-SecreC code are defined in the backend by first calling the method begin_function , then calling the methods corresponding to the body of the function, and then calling the method end_function . The backend should not execute the methods called between begin_function and end_function calls immediately but save them as a function definition and execute them when the defined function is later called using apply , vectorized_apply , or switch_apply . If necessary, the backend may use a different implementation of WireTrait for wires inside a function definition than for ordinary wires, as is done in the dummy backend. Plugins ( extended_arithmetic , vectors , permutation_check ) can be supported through the methods plugin_apply and plugin_apply_wr . The semantics and a sample implementation of those plugins can be seen in the code of the dummy backend. The disjunction plugin is special and uses the method switch_apply instead, also requiring support for sieve functions. The iter plugin is also special and uses vectorized_apply . Method begin_function fn begin_function(&self, sieve_fn: &String, output_moduli: &Vec<&NatType>, input_moduli: Vec<&NatType>) -> (Vec<Wire>, usize); Begin a sieve function definition. Returns wires corresponding to the inputs and a UID for the sieve function (which must be different each time begin_function is called). Method end_function fn end_function(&self, wires_res: Vec<WireOrConst>); End a sieve function definition. wires_res contains for each return value the wire where it was computed or a constant if this return value is constant. Method apply fn apply(&self, uid: usize, output_moduli: Vec<&NatType>, input_wires: Vec<&Wire>) -> Vec<Wire>; Apply a sieve function with the given uid in a non-vectorized way to the values on the input wires. Method vectorized_apply fn vectorized_apply(&self, uid: usize, output_moduli: Vec<&NatType>, input_moduli: Vec<&NatType>, env_moduli: &Vec<NatType>, env_wires: Vec<&Wire>, wrs: Vec<&WireRange>) -> Vec<WireRange>; Apply a sieve function with the given uid in a vectorized way to the values on the input wire ranges wrs . The function is first partially applied to the wires in env_wires and resulting function is then applied in a vectorized way to wrs . Each wire range in wrs has the same length and the output wire ranges must also have the same length. The values of the i th elements of the output wire ranges are obtained by applying the sieve function to the values of the wires in env_wires and the values of the i th elements of the wire ranges in wrs . Method switch_apply fn switch_apply(&self, sieve_fns: &Vec<usize>, default_sieve_fn: usize, ints: &Vec<Integer>, w_modulus: &NatType, output_moduli: Vec<&NatType>, input_moduli: Vec<&NatType>, w: &Wire, wires: Vec<&Wire>, witness_count: u64) -> Vec<Wire>; Apply one of the sieve functions with uids in sieve_fns in a non-vectorized way to the values on the input wires. The disjunction plugin is used to choose which function to apply according to which value in ints (if any) the value on wire w is equal to. If it is not equal to any, the default function (with uid default_sieve_fn ) is chosen. witness_count is the maximum number of witness values used by any of the given functions. If the chosen function uses fewer witness values then the witness stream has been padded with arbitrary values (e.g. zeroes) so that the number of values in the witness stream does not leak the chosen branch. The implementation of switch_apply must also remove those extra values from the witness stream, not just the witness values actually used by the chosen function. Method plugin_apply fn plugin_apply(&self, plugin: &str, operation: &str, params: Vec<&str>, modulus: &NatType, num_outputs: usize, input_wires: Vec<&Wire>) -> Vec<Wire>; Apply a plugin operation that uses a single modulus and has single wires as inputs and outputs. Method plugin_apply_wr fn plugin_apply_wr(&self, plugin: &str, operation: &str, params: Vec<&str>, modulus: &NatType, output_counts: Vec<usize>, input_wrs: Vec<&WireRange>) -> Vec<WireRange>; Apply a plugin operation that uses a single modulus and has wire ranges as inputs and outputs. Other methods These are optional. Method write_headers fn write_headers(&self, ns: &Vec<NatType>, supported_conversions: Vec<(&NatType, &NatType)>, supported_plugins: Vec<&str>); Write IR headers if they could not be written yet when the struct implementing this trait was allocated. ns is the list of fields used in the circuit. supported_conversions is the list of conversions between fields supported in the circuit, the first element of the pair is the input field and the second element is the output field of the conversion. supported_plugins is the list of names of supported plugins. Method get_next_wire_number fn get_next_wire_number(&self) -> u64; For profiling how many wires are used in each part of the code. Method get_rel_file_size fn get_rel_file_size(&self) -> u64; For profiling how many lines of relation file are generated in each part of the code. Method flush fn flush(&self); Flush output. Useful for text-based implementations like IR output. Method finalize fn finalize(&self); Signal that code execution is finished. Method current_status fn current_status(&self) -> bool; This does not seem to be used anywhere.","title":"Trait Methods"},{"location":"5-backend-interface/1-trait-methods/#sieveir-trait-methods","text":"Here we will describe the methods of the SIEVEIR trait, which can be implemented when interfacing a new backend with the ZK-SecreC compiler. Some of the methods are required for all backends, some are optional.","title":"SIEVEIR Trait Methods"},{"location":"5-backend-interface/1-trait-methods/#arithmetic-and-boolean-operations","text":"All of these methods are required. The parameter m is the modulus of the wires, represented with the type NatType . Constants are of the type Integer , which is a type synonym for BigInt from num_bigint .","title":"Arithmetic and boolean operations"},{"location":"5-backend-interface/1-trait-methods/#method-and","text":"fn and(&self, m: &NatType, w1: &Wire, w2: &Wire) -> Wire; Logical conjunction.","title":"Method and"},{"location":"5-backend-interface/1-trait-methods/#method-xor","text":"fn xor(&self, m: &NatType, w1: &Wire, w2: &Wire) -> Wire; Logical exclusive or.","title":"Method xor"},{"location":"5-backend-interface/1-trait-methods/#method-not","text":"fn not(&self, m: &NatType, w1: &Wire) -> Wire; Logical negation.","title":"Method not"},{"location":"5-backend-interface/1-trait-methods/#method-mul","text":"fn mul(&self, m: &NatType, w1: &Wire, w2: &Wire) -> Wire; Modular multiplication.","title":"Method mul"},{"location":"5-backend-interface/1-trait-methods/#method-add","text":"fn add(&self, m: &NatType, w1: &Wire, w2: &Wire) -> Wire; Modular addition.","title":"Method add"},{"location":"5-backend-interface/1-trait-methods/#method-mulc","text":"fn mulc(&self, m: &NatType, w1: &Wire, c2: &Integer) -> Wire; Modular multiplication between value on wire and constant value.","title":"Method mulc"},{"location":"5-backend-interface/1-trait-methods/#method-addc","text":"fn addc(&self, m: &NatType, w1: &Wire, c2: &Integer) -> Wire; Modular addition between value on wire and constant value.","title":"Method addc"},{"location":"5-backend-interface/1-trait-methods/#using-instance-and-witness-streams","text":"These are not strictly required but strongly recommended as otherwise instances and witnesses cannot be used. The methods get_instance_wr and get_witness_wr are not required if the backend does not support wire ranges. The type Value represents any ZK-SecreC value but here it is assumed to be a scalar $pre value.","title":"Using instance and witness streams"},{"location":"5-backend-interface/1-trait-methods/#method-add_instance","text":"fn add_instance(&self, m: &NatType, x: &Value); Add a new value x to the instance stream of modulus m .","title":"Method add_instance"},{"location":"5-backend-interface/1-trait-methods/#method-get_instance","text":"Add a new value x to the instance stream of modulus m . fn get_instance(&self, m: &NatType) -> Wire; Get value of a new wire from the instance stream of modulus m . This function is called sequentially so n-th call loads the n-th value from the instance. The value must be added to the instance using add_instance before it can be read with get_instance or get_instance_wr .","title":"Method get_instance"},{"location":"5-backend-interface/1-trait-methods/#method-get_instance_wr","text":"fn get_instance_wr(&self, m: &NatType, n: usize) -> WireRange; Get n values from instance to a new wire range. This is equivalent to calling get_instance n times but may be more efficient if the backend supports vectorized get_instance . The n values must be added to the instance stream using add_instance before they can be read with get_instance_wr .","title":"Method get_instance_wr"},{"location":"5-backend-interface/1-trait-methods/#method-add_witness","text":"fn add_witness(&self, m: &NatType, x: &Value); Add a new value x to the witness stream of modulus m .","title":"Method add_witness"},{"location":"5-backend-interface/1-trait-methods/#method-get_witness","text":"fn get_witness(&self, m: &NatType) -> Wire; Get value of a new wire from the witness stream of modulus m . This function is called sequentially so n-th call loads the n-th value from the witness. The value must be added to the witness using add_witness before it can be read with get_witness or get_witness_wr .","title":"Method get_witness"},{"location":"5-backend-interface/1-trait-methods/#method-get_witness_wr","text":"fn get_witness_wr(&self, m: &NatType, n: usize) -> WireRange; Get n values from witness to a new wire range. This is equivalent to calling get_witness n times but may be more efficient if the backend supports vectorized get_witness . The n values must be added to the witness stream using add_witness before they can be read with get_witness_wr .","title":"Method get_witness_wr"},{"location":"5-backend-interface/1-trait-methods/#assertions-and-field-switches","text":"Of these, only assert_zero and assert_eq_scalar_vec are required.","title":"Assertions and field switches"},{"location":"5-backend-interface/1-trait-methods/#method-assert_zero","text":"fn assert_zero(&self, m: &NatType, w: &Wire); Assert that the value on the wire is zero.","title":"Method assert_zero"},{"location":"5-backend-interface/1-trait-methods/#method-assert_eq","text":"fn assert_eq(&self, m1: &NatType, w1: &Wire, m2: &NatType, w2: &Wire); Assert that values on two wires (of different moduli) are equal.","title":"Method assert_eq"},{"location":"5-backend-interface/1-trait-methods/#method-assert_eq_scalar_vec","text":"fn assert_eq_scalar_vec(&self, m1: &NatType, w1: &Wire, m2: &NatType, wires: Vec<Wire>); Assert that the value of w1 has binary representation based on values of wires . value(w1) = value(wires[0]) + 2*value(wires[1]) + 4*value(wires[2]) + ... Used for more efficiently implemementing boolean circuit evaluation.","title":"Method assert_eq_scalar_vec"},{"location":"5-backend-interface/1-trait-methods/#method-bool2int","text":"fn bool2int(&self, m: &NatType, w1: &Wire, output_modulus: &NatType) -> Wire; Convert a boolean wire of modulus m to an integer wire of modulus output_modulus .","title":"Method bool2int"},{"location":"5-backend-interface/1-trait-methods/#method-int_field_switch","text":"fn int_field_switch(&self, m: &NatType, w1: &Wire, output_modulus: &NatType) -> Wire; Switch the field of w1 to new modulus m . For conversion of boolean to uint we use bool2int calls instead.","title":"Method int_field_switch"},{"location":"5-backend-interface/1-trait-methods/#constants-cloning-copying-and-dropping-wires","text":"Of these methods, const_bool , zero_wire , clone_wire , and drop_wire are required.","title":"Constants, cloning, copying, and dropping wires"},{"location":"5-backend-interface/1-trait-methods/#method-const_bool","text":"fn const_bool(&self, m: &NatType, b: bool) -> Wire; Load a constant boolean onto a fresh wire.","title":"Method const_bool"},{"location":"5-backend-interface/1-trait-methods/#method-const_uint","text":"fn const_uint(&self, m: &NatType, x: &Value) -> Wire; Load a constant integer onto a fresh wire. Similar to add_instance + get_instance and add_witness + get_witness but for public values.","title":"Method const_uint"},{"location":"5-backend-interface/1-trait-methods/#method-zero_wire","text":"fn zero_wire(&self, m: &NatType) -> Wire; Construct wire that won't be used.","title":"Method zero_wire"},{"location":"5-backend-interface/1-trait-methods/#method-clone_wire","text":"fn clone_wire(&self, w1: &Wire) -> Wire; Clone a wire. Both input and output wire will be deallocated separately. If the underlying wire representation is a raw pointer the clone will have to either copy the pointed data or deal with reference counting. Input and output have the same modulus.","title":"Method clone_wire"},{"location":"5-backend-interface/1-trait-methods/#method-copy_bool","text":"fn copy_bool(&self, m: &NatType, w1: &Wire) -> Wire; Semantically identical to clone_wire where wires have modulus 2 . Internally used to make sure that textual IR1 output is identical to our earlier versions.","title":"Method copy_bool"},{"location":"5-backend-interface/1-trait-methods/#method-drop_wire","text":"fn drop_wire(&self, wire: &mut Wire); Deallocate a wire. Called automatically when the wire goes out of scope. This method should free any memory that is not freed automatically.","title":"Method drop_wire"},{"location":"5-backend-interface/1-trait-methods/#handling-wire-ranges","text":"The methods declare_new_wire_range and declare_delete_wire_range are optional and are not called from the frontend, they are intended to be called from the backend itself. They are used only by backends that implement AllocationTrait . The other methods are required only if the backend supports wire ranges.","title":"Handling wire ranges"},{"location":"5-backend-interface/1-trait-methods/#method-zero_wire_range","text":"fn zero_wire_range(&self, m: &NatType, n: usize) -> WireRange; Construct a wire range of length n that won't be used.","title":"Method zero_wire_range"},{"location":"5-backend-interface/1-trait-methods/#method-clone_wire_range","text":"fn clone_wire_range(&self, wr: &WireRange) -> WireRange; Clone a range of wires.","title":"Method clone_wire_range"},{"location":"5-backend-interface/1-trait-methods/#method-index_wire_range","text":"fn index_wire_range(&self, wr: &WireRange, i: usize) -> Wire; Index a range of wires, returning the wire with index i . The first wire in a range has index 0 .","title":"Method index_wire_range"},{"location":"5-backend-interface/1-trait-methods/#method-slice_wire_range","text":"fn slice_wire_range(&self, wr: &WireRange, ir: &IndexRange) -> WireRange; Slice a range of wires. The struct IndexRange is defined in sieve.rs as follows: pub struct IndexRange { pub first: usize, pub length: usize, } giving the index of the first wire and the length of the slice.","title":"Method slice_wire_range"},{"location":"5-backend-interface/1-trait-methods/#method-wire_to_wire_range","text":"fn wire_to_wire_range(&self, w: &Wire) -> WireRange; Convert a wire into a length-1 wire range.","title":"Method wire_to_wire_range"},{"location":"5-backend-interface/1-trait-methods/#method-drop_wire_range","text":"fn drop_wire_range(&self, wr: &mut WireRange); Drop a wire range. Called automatically when the wire range goes out of scope. This method should free any memory that is not freed automatically.","title":"Method drop_wire_range"},{"location":"5-backend-interface/1-trait-methods/#method-create_vector","text":"fn create_vector(&self, m: &NatType, wocs: Vec<WireOrConst>) -> WireRange; Copy wires or constant values to fresh wires in a wire range, so that they can be used in vectorized operations.","title":"Method create_vector"},{"location":"5-backend-interface/1-trait-methods/#method-declare_new_wire_range","text":"fn declare_new_wire_range(&self, alloc: &Allocation); Allocate a range of wires.","title":"Method declare_new_wire_range"},{"location":"5-backend-interface/1-trait-methods/#method-declare_delete_wire_range","text":"fn declare_delete_wire_range(&self, alloc: &Allocation); Deallocate a range of wires.","title":"Method declare_delete_wire_range"},{"location":"5-backend-interface/1-trait-methods/#sieve-functions-and-plugins","text":"These methods are optional. Functions defined with the sieve keyword in ZK-SecreC code are defined in the backend by first calling the method begin_function , then calling the methods corresponding to the body of the function, and then calling the method end_function . The backend should not execute the methods called between begin_function and end_function calls immediately but save them as a function definition and execute them when the defined function is later called using apply , vectorized_apply , or switch_apply . If necessary, the backend may use a different implementation of WireTrait for wires inside a function definition than for ordinary wires, as is done in the dummy backend. Plugins ( extended_arithmetic , vectors , permutation_check ) can be supported through the methods plugin_apply and plugin_apply_wr . The semantics and a sample implementation of those plugins can be seen in the code of the dummy backend. The disjunction plugin is special and uses the method switch_apply instead, also requiring support for sieve functions. The iter plugin is also special and uses vectorized_apply .","title":"Sieve functions and plugins"},{"location":"5-backend-interface/1-trait-methods/#method-begin_function","text":"fn begin_function(&self, sieve_fn: &String, output_moduli: &Vec<&NatType>, input_moduli: Vec<&NatType>) -> (Vec<Wire>, usize); Begin a sieve function definition. Returns wires corresponding to the inputs and a UID for the sieve function (which must be different each time begin_function is called).","title":"Method begin_function"},{"location":"5-backend-interface/1-trait-methods/#method-end_function","text":"fn end_function(&self, wires_res: Vec<WireOrConst>); End a sieve function definition. wires_res contains for each return value the wire where it was computed or a constant if this return value is constant.","title":"Method end_function"},{"location":"5-backend-interface/1-trait-methods/#method-apply","text":"fn apply(&self, uid: usize, output_moduli: Vec<&NatType>, input_wires: Vec<&Wire>) -> Vec<Wire>; Apply a sieve function with the given uid in a non-vectorized way to the values on the input wires.","title":"Method apply"},{"location":"5-backend-interface/1-trait-methods/#method-vectorized_apply","text":"fn vectorized_apply(&self, uid: usize, output_moduli: Vec<&NatType>, input_moduli: Vec<&NatType>, env_moduli: &Vec<NatType>, env_wires: Vec<&Wire>, wrs: Vec<&WireRange>) -> Vec<WireRange>; Apply a sieve function with the given uid in a vectorized way to the values on the input wire ranges wrs . The function is first partially applied to the wires in env_wires and resulting function is then applied in a vectorized way to wrs . Each wire range in wrs has the same length and the output wire ranges must also have the same length. The values of the i th elements of the output wire ranges are obtained by applying the sieve function to the values of the wires in env_wires and the values of the i th elements of the wire ranges in wrs .","title":"Method vectorized_apply"},{"location":"5-backend-interface/1-trait-methods/#method-switch_apply","text":"fn switch_apply(&self, sieve_fns: &Vec<usize>, default_sieve_fn: usize, ints: &Vec<Integer>, w_modulus: &NatType, output_moduli: Vec<&NatType>, input_moduli: Vec<&NatType>, w: &Wire, wires: Vec<&Wire>, witness_count: u64) -> Vec<Wire>; Apply one of the sieve functions with uids in sieve_fns in a non-vectorized way to the values on the input wires. The disjunction plugin is used to choose which function to apply according to which value in ints (if any) the value on wire w is equal to. If it is not equal to any, the default function (with uid default_sieve_fn ) is chosen. witness_count is the maximum number of witness values used by any of the given functions. If the chosen function uses fewer witness values then the witness stream has been padded with arbitrary values (e.g. zeroes) so that the number of values in the witness stream does not leak the chosen branch. The implementation of switch_apply must also remove those extra values from the witness stream, not just the witness values actually used by the chosen function.","title":"Method switch_apply"},{"location":"5-backend-interface/1-trait-methods/#method-plugin_apply","text":"fn plugin_apply(&self, plugin: &str, operation: &str, params: Vec<&str>, modulus: &NatType, num_outputs: usize, input_wires: Vec<&Wire>) -> Vec<Wire>; Apply a plugin operation that uses a single modulus and has single wires as inputs and outputs.","title":"Method plugin_apply"},{"location":"5-backend-interface/1-trait-methods/#method-plugin_apply_wr","text":"fn plugin_apply_wr(&self, plugin: &str, operation: &str, params: Vec<&str>, modulus: &NatType, output_counts: Vec<usize>, input_wrs: Vec<&WireRange>) -> Vec<WireRange>; Apply a plugin operation that uses a single modulus and has wire ranges as inputs and outputs.","title":"Method plugin_apply_wr"},{"location":"5-backend-interface/1-trait-methods/#other-methods","text":"These are optional.","title":"Other methods"},{"location":"5-backend-interface/1-trait-methods/#method-write_headers","text":"fn write_headers(&self, ns: &Vec<NatType>, supported_conversions: Vec<(&NatType, &NatType)>, supported_plugins: Vec<&str>); Write IR headers if they could not be written yet when the struct implementing this trait was allocated. ns is the list of fields used in the circuit. supported_conversions is the list of conversions between fields supported in the circuit, the first element of the pair is the input field and the second element is the output field of the conversion. supported_plugins is the list of names of supported plugins.","title":"Method write_headers"},{"location":"5-backend-interface/1-trait-methods/#method-get_next_wire_number","text":"fn get_next_wire_number(&self) -> u64; For profiling how many wires are used in each part of the code.","title":"Method get_next_wire_number"},{"location":"5-backend-interface/1-trait-methods/#method-get_rel_file_size","text":"fn get_rel_file_size(&self) -> u64; For profiling how many lines of relation file are generated in each part of the code.","title":"Method get_rel_file_size"},{"location":"5-backend-interface/1-trait-methods/#method-flush","text":"fn flush(&self); Flush output. Useful for text-based implementations like IR output.","title":"Method flush"},{"location":"5-backend-interface/1-trait-methods/#method-finalize","text":"fn finalize(&self); Signal that code execution is finished.","title":"Method finalize"},{"location":"5-backend-interface/1-trait-methods/#method-current_status","text":"fn current_status(&self) -> bool; This does not seem to be used anywhere.","title":"Method current_status"}]}