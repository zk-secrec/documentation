<link rel="stylesheet" type="text/css" href="../../css/site.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../../css/typesystem.css" media="screen "/>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Miltonian" />
<div>
<header class="layout-row bb layout-align-center px-1">
  <div>
    <h1><a href="../../">ZK-SecreC Documentation</a></h1>
  </div>
  <div class="flex">
    
  </div>
  <div>
    2024.09
  </div>
</header>
</div>
<div class="layout-row flex">
  <aside class="br visible">
    <nav class="px-2 layout-col">
          <a class="toc-level-0" href="../../1-user-guide/0-installation/">Docs</a>
          <a class="toc-level-1" href="../../1-user-guide/0-installation/">User Guide</a>
          <a class="toc-level-2" href="../../1-user-guide/0-installation/">Installation</a>
          <a class="toc-level-2" href="../../1-user-guide/1-getting-started/">Getting Started</a>
          <a class="toc-level-1" href="../../2-dev-guide/0-profiling/">Dev Guide</a>
          <a class="toc-level-2" href="../../2-dev-guide/0-profiling/">Profiling</a>
          <a class="toc-level-1" href="../../3-reference/0-values-and-types/">Reference</a>
          <a class="toc-level-2" href="../../3-reference/0-values-and-types/">Values and Types</a>
          <a class="toc-level-2" href="../../3-reference/1-lexical-structure/">Lexical Structure</a>
          <a class="toc-level-2" href="../../3-reference/2-type-level-expressions/">Type Level Expressions</a>
          <a class="toc-level-2" href="../../3-reference/3-expressions/">Expressions</a>
          <a class="toc-level-2" href="../../3-reference/4-top-level/">Top Level</a>
          <a class="toc-level-2" href="../../3-reference/5-type-system/">Type System</a>
          <a class="toc-level-2" href="../../3-reference/6-boxed-and-unboxed-types/">Boxed and Unboxed Types</a>
          <a class="toc-level-1" href="../../4-api/BigInt/">Api</a>
          <a class="toc-level-2" href="../../4-api/BigInt/">BigInt</a>
          <a class="toc-level-2" href="../../4-api/Bitextract/">Bitextract</a>
          <a class="toc-level-2" href="../../4-api/Builtin/">Builtin</a>
          <a class="toc-level-2" href="../../4-api/Char/">Char</a>
          <a class="toc-level-2" href="../../4-api/ChrVec/">ChrVec</a>
          <a class="toc-level-2" href="../../4-api/Date/">Date</a>
          <a class="toc-level-2" href="../../4-api/DFA/">DFA</a>
          <a class="toc-level-2" href="../../4-api/EC/">EC</a>
          <a class="toc-level-2" href="../../4-api/FastFixedPoint/">FastFixedPoint</a>
          <a class="toc-level-2" href="../../4-api/FastFixedPointVec/">FastFixedPointVec</a>
          <a class="toc-level-2" href="../../4-api/FixedPoint/">FixedPoint</a>
          <a class="toc-level-2" href="../../4-api/Inequalities/">Inequalities</a>
          <a class="toc-level-2" href="../../4-api/Integer/">Integer</a>
          <a class="toc-level-2" href="../../4-api/IsFromFirst/">IsFromFirst</a>
          <a class="toc-level-2" href="../../4-api/OldInequalities/">OldInequalities</a>
          <a class="toc-level-2" href="../../4-api/Perm/">Perm</a>
          <a class="toc-level-2" href="../../4-api/Poseidon/">Poseidon</a>
          <a class="toc-level-2" href="../../4-api/Prob/">Prob</a>
          <a class="toc-level-2" href="../../4-api/Ratio/">Ratio</a>
          <a class="toc-level-2" href="../../4-api/SetOp/">SetOp</a>
          <a class="toc-level-2" href="../../4-api/Std/">Std</a>
          <a class="toc-level-2" href="../../4-api/Store/">Store</a>
          <a class="toc-level-2" href="../../4-api/StoreVec/">StoreVec</a>
          <a class="toc-level-2" href="../../4-api/String/">String</a>
          <a class="toc-level-2" href="../../4-api/Text/">Text</a>
          <a class="toc-level-2" href="../../4-api/Vec/">Vec</a>
          <a class="toc-level-2" href="../../4-api/Waksman/">Waksman</a>
          <a class="toc-level-1" href="../../5-backend-interface/0-interfacing-a-new-backend/">Backend Interface</a>
          <a class="toc-level-2" href="../../5-backend-interface/0-interfacing-a-new-backend/">Interfacing a New Backend</a>
          <a class="toc-level-2" href="../../5-backend-interface/1-trait-methods/">Trait Methods</a>
        </nav>
  </aside>
  <div class="px-2 pb-5 body">
<div>
  <h1>Module FastFixedPoint</h1>
</div>
<div>
  <h2>Function add_fixed</h2>
</div>
<code>
pub  fn add_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>The sum of the given two fixed-point numbers. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers. Does not check that the sum fits to this number of bits. Use <code>check_fixed</code> to check it manually when necessary.</p>
  </blockquote>
</div>
<div>
  <h2>Function check_fixed</h2>
</div>
<code>
pub  fn check_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; () $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Check that a fixed-point number fits in its required number of bits. Can be used after an operation or a series of operations that do not do this check. Some operations (e.g. <code>add_fixed</code>, <code>sub_fixed</code>, <code>negate_fixed</code>) have left out this check for efficiency, so that several such operations can be done in row before calling <code>check_fixed</code>. This is safe if the intermediate results do not overflow the modulus (but they do not have to fit into <code>len</code> bits). For example, three fixed-point numbers can be added together by <code>{let w = add_fixed(x, add_fixed(y, z)); check_fixed(w); w}</code>, calling <code>check_fixed</code> only once rather than twice. This is safe if <code>3*(2^len - 1) &lt; N</code>.</p>
  </blockquote>
</div>
<div>
  <h2>Function coef_div_pre</h2>
</div>
<code>
pub  fn coef_div_pre
[
N : Nat,
<span class="citation" data-cites="D">@D</span>
]
(   x : uint[N] $pre <span class="citation" data-cites="D">@D</span>,
   y : uint[N] $pre <span class="citation" data-cites="D">@D</span>,
   pplen : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; uint[N] $pre <span class="citation" data-cites="D">@D</span>
</code>
<div>
  <blockquote>
  <p>A helper function used to implement division in both <code>FastFixedPoint</code> and <code>FastFixedPointVec</code> modules. Intended for standard library programmers only.</p>
  </blockquote>
</div>
<div>
  <h2>Function div_fixed</h2>
</div>
<code>
pub  fn div_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>The ratio of the given two fixed-point numbers. Assumes that they are correctly formed. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers or the ratio does not fit to this number of bits. Also fails if the second operand is zero.</p>
  </blockquote>
</div>
<div>
  <h2>Function eq_fixed</h2>
</div>
<code>
pub  fn eq_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; bool[N] $S <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Test if the given two fixed-point numbers are equal. Assumes that they are correctly formed. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers.</p>
  </blockquote>
</div>
<div>
  <h2>Function fixed</h2>
</div>
<code>
pub  fn fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   coef : uint[N] $S <span class="citation" data-cites="D">@D</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>,
   pplen : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>A new fixed-point number with the given parameters (the integral value that ignores binary point; the number of bits; the number of bits following the binary point). Fails if the integral value does not fit to the required number of bits.</p>
  </blockquote>
</div>
<div>
  <h2>Function fixed_cond</h2>
</div>
<code>
pub  fn fixed_cond
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   b : bool[N] $S <span class="citation" data-cites="D">@D</span>,
   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Oblivious choice according to the given boolean between the given two fixed-point numbers. Assumes that the numbers are correctly formed. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers.</p>
  </blockquote>
</div>
<div>
  <h2>Function fixed_nonnegative</h2>
</div>
<code>
pub  fn fixed_nonnegative
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   coef : uint[N] $S <span class="citation" data-cites="D">@D</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>,
   pplen : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>A new fixed-point number with the given parameters (the integral value that ignores binary point; the number of bits; the number of bits following the binary point). Fails if the new fixed-point number would be negative, or if the integral value does not fit to the required number of bits.</p>
  </blockquote>
</div>
<div>
  <h2>Function fixed_post</h2>
</div>
<code>
pub  fn fixed_post
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $post, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Conversion of the given fixed-point number to the stage <code>$post</code>, putting it on a wire if it is in <code>$pre</code>.</p>
  </blockquote>
</div>
<div>
  <h2>Function fixed_pre</h2>
</div>
<code>
pub  fn fixed_pre
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   f : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $pre, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
</code>
<div>
  <blockquote>
  <p>Conversion of the given fixed-point number to the stage <code>$pre</code>.</p>
  </blockquote>
</div>
<div>
  <h2>Function fixed_prover</h2>
</div>
<code>
pub  fn fixed_prover
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Conversion of the given fixed-point number to the domain <code>@prover</code>.</p>
  </blockquote>
</div>
<div>
  <h2>Function fixed_to_bitstring</h2>
</div>
<code>
pub  fn fixed_to_bitstring
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; string $pre <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Representing the given fixed-point number as a bit string (for testing purposes).</p>
  </blockquote>
</div>
<div>
  <h2>Function fixed_to_string</h2>
</div>
<code>
pub  fn fixed_to_string
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   f : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; string $pre <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Representing the given fixed-point number in decimal (for testing purposes).</p>
  </blockquote>
</div>
<div>
  <h2>Function fixed_verifier</h2>
</div>
<code>
pub  fn fixed_verifier
[
N : Nat,
$S
]
(   x : Fixed[N, $S, <span class="citation" data-cites="public">@public</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="verifier">@verifier</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Conversion of the given fixed-point number from the domain <code>@public</code> to the domain <code>@verifier</code>.</p>
  </blockquote>
</div>
<div>
  <h2>Function ge_fixed</h2>
</div>
<code>
pub  fn ge_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; bool[N] $S <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Test if the first given fixed-point number is greater than or equal to the second one. Assumes that they are correctly formed. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers.</p>
  </blockquote>
</div>
<div>
  <h2>Function gt_fixed</h2>
</div>
<code>
pub  fn gt_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; bool[N] $S <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Test if the first given fixed-point number is less than the second one. Assumes that they are correctly formed. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers.</p>
  </blockquote>
</div>
<div>
  <h2>Function increase_len_fixed</h2>
</div>
<code>
pub  fn increase_len_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   new_len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Increases the number of bits of a fixed-point number, without changing its value. Fails if the new <code>len</code> is less than the old <code>len</code>. Does not check that the new <code>len</code> fits in the modulus.</p>
  </blockquote>
</div>
<div>
  <h2>Function le_fixed</h2>
</div>
<code>
pub  fn le_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; bool[N] $S <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Test if the first given fixed-point number is less than or equal to the second one. Assumes that they are correctly formed. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers.</p>
  </blockquote>
</div>
<div>
  <h2>Function lt_fixed</h2>
</div>
<code>
pub  fn lt_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; bool[N] $S <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Test if the first given fixed-point number is less than the second one. Assumes that they are correctly formed. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers.</p>
  </blockquote>
</div>
<div>
  <h2>Function lt_signed</h2>
</div>
<code>
pub  fn lt_signed
[
$S,
<span class="citation" data-cites="D">@D</span>,
N : Nat
]
(   x : uint[N] $S <span class="citation" data-cites="D">@D</span>,
   y : uint[N] $S <span class="citation" data-cites="D">@D</span>,
   bw : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; bool[N] $S <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Signed comparison of two integers in <code>uint[N]</code>, i.e. <code>x</code> and <code>y</code> are interpreted as bw-bit signed integers in the range <code>-2^(bw-1) .. 2^(bw-1)-1</code>. Tests if <code>x</code> is less than <code>y</code>.</p>
  </blockquote>
</div>
<div>
  <h2>Function max_fixed</h2>
</div>
<code>
pub  fn max_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Find the maximum of two fixed-point numbers. Assumes that they are correctly formed. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers.</p>
  </blockquote>
</div>
<div>
  <h2>Function min_fixed</h2>
</div>
<code>
pub  fn min_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Find the minimum of two fixed-point numbers. Assumes that they are correctly formed. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers.</p>
  </blockquote>
</div>
<div>
  <h2>Function mult_fixed</h2>
</div>
<code>
pub  fn mult_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>The product of the given two fixed-point numbers. Assumes that they are correctly formed. The result is rounded to the same number of bits after the binary point as the arguments. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers or the product does not fit to this number of bits.</p>
  </blockquote>
</div>
<div>
  <h2>Function mult_fixed_alternative</h2>
</div>
<code>
pub  fn mult_fixed_alternative
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>An alternative implementation of <code>mult_fixed</code>, using <code>mult_fixed_exact</code>, followed by <code>round_down_fixed</code>. Should have same semantics and similar performance.</p>
  </blockquote>
</div>
<div>
  <h2>Function mult_fixed_exact</h2>
</div>
<code>
pub  fn mult_fixed_exact
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>The product of the given two fixed-point numbers. Does not round the result, instead the <code>len</code> and <code>pplen</code> of the result are the sum of the <code>len</code> and <code>pplen</code> of the arguments, respectively. This is much faster than <code>mult_fixed</code>. If the modulus is not large enough to fit numbers with new <code>len</code> bits then it fails. If the inputs are correctly formed (fit in the required number of bits) then the result is as well.</p>
  </blockquote>
</div>
<div>
  <h2>Function negate_fixed</h2>
</div>
<code>
pub  fn negate_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Negation of the given fixed-point number. If the given number is the smallest one representable within the number of bits and the number of bits after the binary point, then overflow will occur which is not checked. Use <code>check_fixed</code> to check it manually when necessary.</p>
  </blockquote>
</div>
<div>
  <h2>Function neq_fixed</h2>
</div>
<code>
pub  fn neq_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; bool[N] $S <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Test if the given two fixed-point numbers are distinct. Assumes that they are correctly formed. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers.</p>
  </blockquote>
</div>
<div>
  <h2>Function round_down_fixed</h2>
</div>
<code>
pub  fn round_down_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   new_len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>,
   new_pplen : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Reduces <code>pplen</code> by rounding towards minus infinity. The arguments specify both a new <code>len</code> and a new <code>pplen</code>. Fails if the new <code>pplen</code> is greater than the old one or if the rounded result does not fit in the new <code>len</code> bits or if adding the rounded-down bits back to the new <code>len</code> would overflow the modulus. The input fixed-point number does not have to fit in its <code>len</code> bits.</p>
  </blockquote>
</div>
<div>
  <h2>Function round_down_fixed_to_int</h2>
</div>
<code>
pub  fn round_down_fixed_to_int
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; uint[N] $S <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Rounds a fixed-point number down to the nearest integer less than or equal to it, i.e. it takes the floor of the fixed-point number. Fails if the input does not fit into its <code>len</code> bits.</p>
  </blockquote>
</div>
<div>
  <h2>Function round_fixed_to_nearest_int</h2>
</div>
<code>
pub  fn round_fixed_to_nearest_int
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; uint[N] $S <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Rounds a fixed-point number to the nearest integer, either up or down whichever is closer. <code>n + 0.5</code>, for an integer <code>n</code>, is rounded to <code>n + 1</code>, even for negative <code>n</code>. Fails if the output does not fit into its <code>len</code> bits, which can also occur for correctly formed inputs that are so close to the maximum allowed value that rounding up to an integer overflows the required number of bits. If the input is slightly below the minimum allowed value but after rounding up fits in the required number of bits then it does not fail.</p>
  </blockquote>
</div>
<div>
  <h2>Function round_up_fixed_to_int</h2>
</div>
<code>
pub  fn round_up_fixed_to_int
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; uint[N] $S <span class="citation" data-cites="D">@D</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Rounds a fixed-point number up to the nearest integer greater than or equal to it, i.e. it takes the ceiling of the fixed-point number. Fails if the output does not fit into its <code>len</code> bits, which can also occur for correctly formed inputs that are so close to the maximum allowed value that rounding up to an integer overflows the required number of bits. If the input is slightly below the minimum allowed value but after rounding up fits in the required number of bits then it does not fail.</p>
  </blockquote>
</div>
<div>
  <h2>Function signed_uintN_to_uint</h2>
</div>
<code>
pub  fn signed_uintN_to_uint
[
N : Nat,
<span class="citation" data-cites="D">@D</span>
]
(   x : uint[N] $pre <span class="citation" data-cites="D">@D</span>
) 
-&gt; uint $pre <span class="citation" data-cites="D">@D</span>
</code>
<div>
  <blockquote>
  <p>Convert a <code>uint[N]</code> integer in <code>$pre</code> into a <code>uint</code>, interpreting the <code>uint[N]</code> as a value in the range <code>-N/2 .. N-N/2-1</code> instead of <code>0 .. N-1</code>. E.g. <code>N-1</code> is converted to <code>-1</code>, etc.</p>
  </blockquote>
</div>
<div>
  <h2>Function sqrt_fixed</h2>
</div>
<code>
unchecked eff [<em>,</em>,*] -&gt; [<em>,</em>,*] ! &lt;$S&gt;<br>
pub  fn sqrt_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Square root of the given fixed-point number. Assumes that the number is correctly formed. Fails if the given fixed-point number is negative.</p>
  </blockquote>
</div>
<div>
  <h2>Function sqrt_fixed_pre</h2>
</div>
<code>
pub  fn sqrt_fixed_pre
[
N : Nat,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $pre, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $pre, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>Square root of the given fixed-point number in <code>$pre</code>. Assumes that the number is correctly formed. Fails if the given fixed-point number is negative.</p>
  </blockquote>
</div>
<div>
  <h2>Function sub_fixed</h2>
</div>
<code>
pub  fn sub_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   x : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>The difference of the given two fixed-point numbers. Fails if the numbers of bits or the numbers of bits after the binary point differ in the given fixed-point numbers. Does not check that the sum fits to this number of bits. Use <code>check_fixed</code> to check it manually when necessary.</p>
  </blockquote>
</div>
<div>
  <h2>Function uint_to_fixed</h2>
</div>
<code>
pub  fn uint_to_fixed
[
N : Nat,
$S,
<span class="citation" data-cites="D">@D</span>
]
(   n : uint[N] $S <span class="citation" data-cites="D">@D</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>,
   pplen : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; Fixed[N, $S, <span class="citation" data-cites="D">@D</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N]
</code>
<div>
  <blockquote>
  <p>A new fixed-point number whose value is the integer given as the first argument, with the number of bits and the number of bits after the binary point given as the second and the third arguments. Fails if the integral value (along with zeros after the binary point) does not fit to the required number of bits but does not check that it fits into the modulus (if overflowing the modulus wraps it around to a value that fits in the number of bits then it is not detected).</p>
  </blockquote>
</div>

  </div>
</div>
