<link rel="stylesheet" type="text/css" href="../../css/site.css" media="screen" />
<link rel="stylesheet" type="text/css" href="../../css/typesystem.css" media="screen "/>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Miltonian" />
<div>
<header class="layout-row bb layout-align-center px-1">
  <div>
    <h1><a href="../../">ZK-SecreC Documentation</a></h1>
  </div>
  <div class="flex">
    
  </div>
  <div>
    2024.09
  </div>
</header>
</div>
<div class="layout-row flex">
  <aside class="br visible">
    <nav class="px-2 layout-col">
          <a class="toc-level-0" href="../../1-user-guide/0-installation/">Docs</a>
          <a class="toc-level-1" href="../../1-user-guide/0-installation/">User Guide</a>
          <a class="toc-level-2" href="../../1-user-guide/0-installation/">Installation</a>
          <a class="toc-level-2" href="../../1-user-guide/1-getting-started/">Getting Started</a>
          <a class="toc-level-1" href="../../2-dev-guide/0-profiling/">Dev Guide</a>
          <a class="toc-level-2" href="../../2-dev-guide/0-profiling/">Profiling</a>
          <a class="toc-level-1" href="../../3-reference/0-values-and-types/">Reference</a>
          <a class="toc-level-2" href="../../3-reference/0-values-and-types/">Values and Types</a>
          <a class="toc-level-2" href="../../3-reference/1-lexical-structure/">Lexical Structure</a>
          <a class="toc-level-2" href="../../3-reference/2-type-level-expressions/">Type Level Expressions</a>
          <a class="toc-level-2" href="../../3-reference/3-expressions/">Expressions</a>
          <a class="toc-level-2" href="../../3-reference/4-top-level/">Top Level</a>
          <a class="toc-level-2" href="../../3-reference/5-type-system/">Type System</a>
          <a class="toc-level-2" href="../../3-reference/6-boxed-and-unboxed-types/">Boxed and Unboxed Types</a>
          <a class="toc-level-1" href="../../4-api/BigInt/">Api</a>
          <a class="toc-level-2" href="../../4-api/BigInt/">BigInt</a>
          <a class="toc-level-2" href="../../4-api/Bitextract/">Bitextract</a>
          <a class="toc-level-2" href="../../4-api/Builtin/">Builtin</a>
          <a class="toc-level-2" href="../../4-api/Char/">Char</a>
          <a class="toc-level-2" href="../../4-api/ChrVec/">ChrVec</a>
          <a class="toc-level-2" href="../../4-api/Date/">Date</a>
          <a class="toc-level-2" href="../../4-api/DFA/">DFA</a>
          <a class="toc-level-2" href="../../4-api/EC/">EC</a>
          <a class="toc-level-2" href="../../4-api/FastFixedPoint/">FastFixedPoint</a>
          <a class="toc-level-2" href="../../4-api/FastFixedPointVec/">FastFixedPointVec</a>
          <a class="toc-level-2" href="../../4-api/FixedPoint/">FixedPoint</a>
          <a class="toc-level-2" href="../../4-api/Inequalities/">Inequalities</a>
          <a class="toc-level-2" href="../../4-api/Integer/">Integer</a>
          <a class="toc-level-2" href="../../4-api/IsFromFirst/">IsFromFirst</a>
          <a class="toc-level-2" href="../../4-api/OldInequalities/">OldInequalities</a>
          <a class="toc-level-2" href="../../4-api/Perm/">Perm</a>
          <a class="toc-level-2" href="../../4-api/Poseidon/">Poseidon</a>
          <a class="toc-level-2" href="../../4-api/Prob/">Prob</a>
          <a class="toc-level-2" href="../../4-api/Ratio/">Ratio</a>
          <a class="toc-level-2" href="../../4-api/SetOp/">SetOp</a>
          <a class="toc-level-2" href="../../4-api/Std/">Std</a>
          <a class="toc-level-2" href="../../4-api/Store/">Store</a>
          <a class="toc-level-2" href="../../4-api/StoreVec/">StoreVec</a>
          <a class="toc-level-2" href="../../4-api/String/">String</a>
          <a class="toc-level-2" href="../../4-api/Text/">Text</a>
          <a class="toc-level-2" href="../../4-api/Vec/">Vec</a>
          <a class="toc-level-2" href="../../4-api/Waksman/">Waksman</a>
          <a class="toc-level-1" href="../../5-backend-interface/0-interfacing-a-new-backend/">Backend Interface</a>
          <a class="toc-level-2" href="../../5-backend-interface/0-interfacing-a-new-backend/">Interfacing a New Backend</a>
          <a class="toc-level-2" href="../../5-backend-interface/1-trait-methods/">Trait Methods</a>
        </nav>
  </aside>
  <div class="px-2 pb-5 body">
<div>
  <h1>Module Vec</h1>
</div>
<div>
  <h2>Function abs_uv</h2>
</div>
<code>
pub  fn abs_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>The absolute values of the elements in the given vector on wires, all values being considered as signed integers with the number of bits given as the second argument.</p>
  </blockquote>
</div>
<div>
  <h2>Function add_preuint_uv</h2>
</div>
<code>
pub  fn add_preuint_uv
[
N : Nat
]
(   c : uint[N] $pre <span class="citation" data-cites="public">@public</span>,
   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Adding the constant in <code>$pre</code> to all elements of the vector on wires.</p>
  </blockquote>
</div>
<div>
  <h2>Function add_uint_uv</h2>
</div>
<code>
pub  fn add_uint_uv
[
N : Nat
]
(   c : uint[N] $post <span class="citation" data-cites="prover">@prover</span>,
   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Adding the fixed value on wire to all elements of the vector on wires.</p>
  </blockquote>
</div>
<div>
  <h2>Function and_uv</h2>
</div>
<code>
pub  fn and_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Pointwise logical conjunction of given two vectors on wires, 1 meaning true and 0 meaning false.</p>
  </blockquote>
</div>
<div>
  <h2>Function assert_eq_uv</h2>
</div>
<code>
pub  fn assert_eq_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; () $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Assertion of terms in each pair of corresponding elements of two given vectors on wires being equal.</p>
  </blockquote>
</div>
<div>
  <h2>Function assert_lt_uv</h2>
</div>
<code>
pub  fn assert_lt_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; () $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Assertion of every element in the first vector on wires being less than the corresponding element in the second vector on wire. All values are considered as unsigned integers with the number of bits given as the third argument.</p>
  </blockquote>
</div>
<div>
  <h2>Function assert_one_uv</h2>
</div>
<code>
pub  fn assert_one_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; () $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Assertion of all elements of given vector on wires being equal to one.</p>
  </blockquote>
</div>
<div>
  <h2>Function assert_zero_uv</h2>
</div>
<code>
pub  fn assert_zero_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; () $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Assertion of all elements of given vector on wires being zeros.</p>
  </blockquote>
</div>
<div>
  <h2>Function bitextract_uv</h2>
</div>
<code>
pub  fn bitextract_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; list[arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>The little endian binary representations of the integers in the given vector on wires. The second argument is the public length of the resulting list of vectors on wires. Every vector in the resulting list contains the corresponding bit in each representation. If any of the integers cannot be represented by the expected number of bits then a run time error occurs.</p>
  </blockquote>
</div>
<div>
  <h2>Function check_bit_uv</h2>
</div>
<code>
pub  fn check_bit_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; () $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Assertion that all elements of the given vector on wires are bits (either 0 or 1).</p>
  </blockquote>
</div>
<div>
  <h2>Function ge_uv</h2>
</div>
<code>
pub  fn ge_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Pointwise greater-than-or-equal-to relation of two vectors on wires, all values being considered as unsigned integers with the number of bits given as the third argument. In the result, 1 means true (in relation), 0 means false (not in relation).</p>
  </blockquote>
</div>
<div>
  <h2>Function ge_uv_uint</h2>
</div>
<code>
pub  fn ge_uv_uint
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : uint[N] $post <span class="citation" data-cites="prover">@prover</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Greater-than-or-equal-to relation applied to each element of the given vector on wires and the fixed value on wire. All values are considered as unsigned integers with the number of bits given as the third argument. In the result, 1 means true (in relation), 0 means false (not in relation).</p>
  </blockquote>
</div>
<div>
  <h2>Function gt_uv</h2>
</div>
<code>
pub  fn gt_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Pointwise greater-than relation of two vectors on wires, all values being considered as unsigned integers with the number of bits given as the third argument. In the result, 1 means true (in relation), 0 means false (not in relation).</p>
  </blockquote>
</div>
<div>
  <h2>Function gt_uv_uint</h2>
</div>
<code>
pub  fn gt_uv_uint
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : uint[N] $post <span class="citation" data-cites="prover">@prover</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Greater-than relation applied to each element of the given vector on wires and the fixed value on wire. All values are considered as unsigned integers with the number of bits given as the third argument. In the result, 1 means true (in relation), 0 means false (not in relation).</p>
  </blockquote>
</div>
<div>
  <h2>Function is_nonnegative_uv</h2>
</div>
<code>
pub  fn is_nonnegative_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>The signs of the elements in the given vector on wires, all considered as signed integers with the number of bits given as the second argument. In the result, 1 means non-negative and 0 means negative.</p>
  </blockquote>
</div>
<div>
  <h2>Function le_uv</h2>
</div>
<code>
pub  fn le_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Pointwise less-than-or-equal-to relation of two vectors on wires, all values being considered as unsigned integers with the number of bits given as the third argument. In the result, 1 means true (in relation), 0 means false (not in relation).</p>
  </blockquote>
</div>
<div>
  <h2>Function le_uv_uint</h2>
</div>
<code>
pub  fn le_uv_uint
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : uint[N] $post <span class="citation" data-cites="prover">@prover</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Less-than-or-equal-to relation applied to each element of the given vector on wires and the fixed value on wire. All values are considered as unsigned integers with the number of bits given as the third argument. In the result, 1 means true (in relation), 0 means false (not in relation).</p>
  </blockquote>
</div>
<div>
  <h2>Function lt_uv</h2>
</div>
<code>
pub  fn lt_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Pointwise less-than relation of two vectors on wires, all values being considered as unsigned integers with the number of bits given as the third argument. In the result, 1 means true (in relation), 0 means false (not in relation).</p>
  </blockquote>
</div>
<div>
  <h2>Function lt_uv_uint</h2>
</div>
<code>
pub  fn lt_uv_uint
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   y : uint[N] $post <span class="citation" data-cites="prover">@prover</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Less-than relation applied to each element of the given vector on wires and the fixed value on wire. All values are considered as unsigned integers with the number of bits given as the third argument. In the result, 1 means true (in relation), 0 means false (not in relation).</p>
  </blockquote>
</div>
<div>
  <h2>Function max_uint_uv</h2>
</div>
<code>
pub  fn max_uint_uv
[
N : Nat
]
(   x : uint[N] $post <span class="citation" data-cites="prover">@prover</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Maximum of each element of the given vector on wires with the fixed value on wire. All values are considered as unsigned integers with the number of bits given as the third argument.</p>
  </blockquote>
</div>
<div>
  <h2>Function max_uv</h2>
</div>
<code>
pub  fn max_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Pointwise maximum of two vectors on wires, all values being considered as unsigned integers with the number of bits given as the third argument.</p>
  </blockquote>
</div>
<div>
  <h2>Function min_uint_uv</h2>
</div>
<code>
pub  fn min_uint_uv
[
N : Nat
]
(   x : uint[N] $post <span class="citation" data-cites="prover">@prover</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Minimum of each element of the given vector on wires with the fixed value on wire. All values are considered as unsigned integers with the number of bits given as the third argument.</p>
  </blockquote>
</div>
<div>
  <h2>Function min_uv</h2>
</div>
<code>
pub  fn min_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Pointwise minimum of two vectors on wires, all values being considered as unsigned integers with the number of bits given as the third argument.</p>
  </blockquote>
</div>
<div>
  <h2>Function mul_preuint_uv</h2>
</div>
<code>
pub  fn mul_preuint_uv
[
N : Nat
]
(   c : uint[N] $pre <span class="citation" data-cites="public">@public</span>,
   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Multiplying all elements of the vector on wires with the constant in <code>$pre</code>.</p>
  </blockquote>
</div>
<div>
  <h2>Function mul_uint_uv</h2>
</div>
<code>
pub  fn mul_uint_uv
[
N : Nat
]
(   c : uint[N] $post <span class="citation" data-cites="prover">@prover</span>,
   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Multiplying all elements of the vector on wires with the fixed value on wire.</p>
  </blockquote>
</div>
<div>
  <h2>Function negate_uv</h2>
</div>
<code>
pub  fn negate_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Negating all elements of the vector on wires.</p>
  </blockquote>
</div>
<div>
  <h2>Function not_uv</h2>
</div>
<code>
pub  fn not_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Pointwise logical negation of given vector on wires, 1 meaning true and 0 meaning false.</p>
  </blockquote>
</div>
<div>
  <h2>Function or_uv</h2>
</div>
<code>
pub  fn or_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Pointwise logical disjunction of given two vectors on wires, 1 meaning true and 0 meaning false.</p>
  </blockquote>
</div>
<div>
  <h2>Function prod_uv</h2>
</div>
<code>
unchecked eff [*] -&gt; * ! &lt;$post&gt;<br>
pub  fn prod_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; uint[N] $post <span class="citation" data-cites="prover">@prover</span>
<br>where
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>The product of all elements of a vector on wires.</p>
  </blockquote>
</div>
<div>
  <h2>Function scalar_prod_uv</h2>
</div>
<code>
pub  fn scalar_prod_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; uint[N] $post <span class="citation" data-cites="prover">@prover</span>
<br>where
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>The scalar (dot) product of two vectors on wires.</p>
  </blockquote>
</div>
<div>
  <h2>Function sub_preuint_uv</h2>
</div>
<code>
pub  fn sub_preuint_uv
[
N : Nat
]
(   c : uint[N] $pre <span class="citation" data-cites="public">@public</span>,
   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Subtracting all elements of a vector on wires from a constant in <code>$pre</code>.</p>
  </blockquote>
</div>
<div>
  <h2>Function sub_uint_uv</h2>
</div>
<code>
pub  fn sub_uint_uv
[
N : Nat
]
(   c : uint[N] $post <span class="citation" data-cites="prover">@prover</span>,
   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Subtracting all elements of a vector on wires from a fixed value on wire.</p>
  </blockquote>
</div>
<div>
  <h2>Function sub_uv</h2>
</div>
<code>
pub  fn sub_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Subtracting the second vector on wires from the first one pointwise. More efficient than vectorized subtraction due to negation being done via multiplying by constant -1 in <code>$pre</code>.</p>
  </blockquote>
</div>
<div>
  <h2>Function sum_uv</h2>
</div>
<code>
unchecked eff [*] -&gt; * ! &lt;$post&gt;<br>
pub  fn sum_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; uint[N] $post <span class="citation" data-cites="prover">@prover</span>
<br>where
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>The sum of all elements of a vector on wires.</p>
  </blockquote>
</div>
<div>
  <h2>Function vectorized_bitextracts</h2>
</div>
<code>
pub  fn vectorized_bitextracts
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   len : uint[18446744073709551616] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; list[arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>A synonym of <code>bitextract_uv</code>.</p>
  </blockquote>
</div>
<div>
  <h2>Function xor_uv</h2>
</div>
<code>
pub  fn xor_uv
[
N : Nat
]
(   xs : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>,
   ys : arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
) 
-&gt; arr[uint[N] $post <span class="citation" data-cites="prover">@prover</span>] $pre <span class="citation" data-cites="public">@public</span>
<br>where
<br>&nbsp;&nbsp;Field[N],
<br>&nbsp;&nbsp;Vectorization
</code>
<div>
  <blockquote>
  <p>Pointwise xor of given two vectors on wires, 1 meaning true and 0 meaning false.</p>
  </blockquote>
</div>

  </div>
</div>
